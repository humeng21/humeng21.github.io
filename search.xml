<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微信小程序与后端SpringBoot通信</title>
      <link href="/2019/02/03/wei-xin-xiao-cheng-xu-yu-hou-duan-springboot-tong-xin/"/>
      <url>/2019/02/03/wei-xin-xiao-cheng-xu-yu-hou-duan-springboot-tong-xin/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序与后端SpringBoot通信"><a href="#微信小程序与后端SpringBoot通信" class="headerlink" title="微信小程序与后端SpringBoot通信"></a>微信小程序与后端SpringBoot通信</h1><h3 id="案例概述"><a href="#案例概述" class="headerlink" title="案例概述"></a>案例概述</h3><p>微信小程序请求后端SpirngBoot,中间使用Ngrok做内网穿透.<br><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/CE885778600E42938491F27E91BC8E79/2661" alt></p><h3 id="内网穿透Ngrok配置"><a href="#内网穿透Ngrok配置" class="headerlink" title="内网穿透Ngrok配置"></a>内网穿透Ngrok配置</h3><h3 id="下载Ngrok"><a href="#下载Ngrok" class="headerlink" title="下载Ngrok"></a>下载Ngrok</h3><blockquote><p><a href="https://ngrok.com/download" target="_blank" rel="noopener">https://ngrok.com/download</a></p></blockquote><h3 id="注册并配置Ngrok认证"><a href="#注册并配置Ngrok认证" class="headerlink" title="注册并配置Ngrok认证"></a>注册并配置Ngrok认证</h3><p>注册完Ngrok之后进入个人主页在Auth页面找到自己的验证码,然后打开Ngrok认证即可</p><p><img src="https://s2.ax1x.com/2019/07/03/ZtnNxe.png" alt></p><h3 id="配置端口和协议"><a href="#配置端口和协议" class="headerlink" title="配置端口和协议"></a>配置端口和协议</h3><p>我这里的端口是8181,因为我Tomcat的端口是8181\</p><blockquote><p>ngrok http 8181</p></blockquote><h3 id="Ngrok配置完成"><a href="#Ngrok配置完成" class="headerlink" title="Ngrok配置完成"></a>Ngrok配置完成</h3><p>配置完成之后Ngrok会为我们提供两个链接,一个是http协议的一个市https协议的.</p><p>Ngrok的作用说白了就是将你本地某个端口上运行的服务暴露在了公网上.</p><p>这里的穿透指的就是将内网中的服务穿过防火墙.<br><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/ED9712F8F49443C1B0A9D65EAA8B6E8A/2665" alt></p><h3 id="后端SpringBoot"><a href="#后端SpringBoot" class="headerlink" title="后端SpringBoot"></a>后端SpringBoot</h3><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>接收微信小程序发来的请求,并根据请求做出响应</p><pre><code>package le.controll;import le.domain.Info;import le.utils.JSONResult;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/*** @program: SpringBootIntrodoction* @description:* @author: Mr.Han* @create: 2019-01-26 22:16**/@Controllerpublic class QuickController2 {    @RequestMapping(&quot;/info&quot;)    @ResponseBody    public JSONResult quick(Info info) {        System.out.println(info.toString());        return JSONResult.ok(info);    }}</code></pre><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><pre><code>package le.domain;import java.io.Serializable;/*** @program: SpringBootIntrodoction* @description: 测试实体类* @author: Mr.Han* @create: 2019-02-01 14:13**/public class Info implements Serializable {    private String name;    private String personName;    private Integer age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getPersonName() {        return personName;    }    public void setPersonName(String personName) {        this.personName = personName;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    @Override    public String toString() {        return &quot;Info{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, personName=&#39;&quot; + personName + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><h3 id="JSON工具类"><a href="#JSON工具类" class="headerlink" title="JSON工具类"></a>JSON工具类</h3><pre><code>package chen.utils;import chen.domain.Info;import com.fasterxml.jackson.databind.util.JSONPObject;import org.springframework.boot.configurationprocessor.json.JSONObject;/*** @program: SpringBootIntrodoction* @description: 实体类转换成JSON* @author: Mr.Han* @create: 2019-02-01 14:17**/public class JSONResult {    // 响应业务状态    private Integer status;    // 响应消息    private String msg;    // 响应中的数据    private Object data;    private String ok;    // 不使用    public static JSONResult build(Integer status, String msg, Object data) {        return new JSONResult(status, msg, data);    }    public static JSONResult ok(Object data) {        return new JSONResult(data);    }    public static JSONResult ok() {        return new JSONResult(null);    }    public static JSONResult errorMsg(String msg) {        return new JSONResult(500, msg, null);    }    public static JSONResult errorMap(Object data) {        return new JSONResult(501, &quot;error&quot;, data);    }    public static JSONResult errorTokenMsg(String msg) {        return new JSONResult(502, msg, null);    }    public static JSONResult errorException(String msg) {        return new JSONResult(555, msg, null);    }    public JSONResult() {    }    public JSONResult(Integer status, String msg, Object data) {        this.status = status;        this.msg = msg;        this.data = data;    }    public JSONResult(Object data) {        this.status = 200;        this.msg = &quot;OK&quot;;        this.data = data;    }    public Boolean isOK() {        return this.status == 200;    }    public Integer getStatus() {        return status;    }    public void setStatus(Integer status) {        this.status = status;    }    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }    public Object getData() {        return data;    }    public void setData(Object data) {        this.data = data;    }    public String getOk() {        return ok;    }    public void setOk(String ok) {        this.ok = ok;    }}</code></pre><h3 id="微信小程序端"><a href="#微信小程序端" class="headerlink" title="微信小程序端"></a>微信小程序端</h3><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><pre><code>&lt;view bindtap=&quot;clickMe&quot;&gt;点击发送请求&lt;/view&gt;</code></pre><p>绑定了一个bindtap事件,点击的时候发送请求</p><h3 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h3><pre><code>// pages/requestinterface/requestinterface.jsPage({  /**  * 页面的初始数据  */  data: {  },  clickMe: function() {    wx.request({      url: &#39;ngrok公网接口&#39;,      data: {        personName: &quot;张三的父亲&quot;,        name: &quot;张三&quot;,        age: 18      },      header: {        &#39;content-type&#39;: &#39;application/json&#39;       },      success(res) {        console.log(res.data)      }    })  }})</code></pre><h3 id="完整的流程"><a href="#完整的流程" class="headerlink" title="完整的流程"></a>完整的流程</h3><p><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/7DA9DB9E98644776B0AD870AAAC8523C/2667" alt></p><h3 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h3><p>因为我们使用的是Ngrok做的内网穿透,微信小程序默认识别出Ngrok的接口时非法的.<br><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/1A5B10B7B372467BA836F71645423091/2669" alt></p><p>这时候我们就必须要<strong>设置不校验合法域名</strong></p><p><img src="https://note.youdao.com/yws/public/resource/a7b28e89afc8e429d20c7293f6faa483/xmlnote/5C3B2976BF574C7780F48218C16B37B3/2671" alt></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 用户和组管理</title>
      <link href="/2018/08/26/linux-yong-hu-he-zu-guan-li/"/>
      <url>/2018/08/26/linux-yong-hu-he-zu-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-用户和组管理"><a href="#Linux-用户和组管理" class="headerlink" title="Linux 用户和组管理"></a>Linux 用户和组管理</h1><p>Linux 操作系统是一个多用户操作系统，它允许多用户同时登录到系统上并使用资源。系统会根据账户来区分每个用户的文件，进程，任务和工作环境，使得每个用户工作都不受干扰。</p><h1 id="使用-Root-用户"><a href="#使用-Root-用户" class="headerlink" title="使用 Root 用户"></a>使用 Root 用户</h1><p>在实际生产操作中，我们基本上都是使用超级管理员账户操作 Linux 系统，也就是 Root 用户，Linux 系统默认是关闭 Root 账户的，我们需要为 Root 用户设置一个初始密码以方便我们使用。</p><h3 id="设置-Root-账户密码"><a href="#设置-Root-账户密码" class="headerlink" title="设置 Root 账户密码"></a>设置 Root 账户密码</h3><pre><code>sudo passwd root</code></pre><h3 id="切换到-Root"><a href="#切换到-Root" class="headerlink" title="切换到 Root"></a>切换到 Root</h3><pre><code>su</code></pre><h3 id="设置允许远程登录-Root"><a href="#设置允许远程登录-Root" class="headerlink" title="设置允许远程登录 Root"></a>设置允许远程登录 Root</h3><pre><code>nano /etc/ssh/sshd_config# Authentication:LoginGraceTime 120#PermitRootLogin without-password     //注释此行PermitRootLogin yes                             //加入此行StrictModes yes重启服务service ssh restart</code></pre><h1 id="用户账户说明"><a href="#用户账户说明" class="headerlink" title="用户账户说明"></a>用户账户说明</h1><h3 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h3><p>普通用户在系统上的任务是进行普通操作</p><h3 id="超级管理员"><a href="#超级管理员" class="headerlink" title="超级管理员"></a>超级管理员</h3><p>管理员在系统上的任务是对普通用户和整个系统进行管理。对系统具有绝对的控制权，能够对系统进行一切操作。用 root 表示，root 用户在系统中拥有最高权限，默认下 Ubuntu 用户的 root 用户是不能登录的。</p><h1 id="安装时创建的系统用户"><a href="#安装时创建的系统用户" class="headerlink" title="安装时创建的系统用户"></a>安装时创建的系统用户</h1><p>此用户创建时被添加到 admin 组中，在 Ubuntu 中，admin 组中的用户默认是可以使用 sudo 命令来执行只有管理员才能执行的命令的。如果不使用 <code>sudo</code> 就是一个普通用户。</p><h1 id="组账户说明"><a href="#组账户说明" class="headerlink" title="组账户说明"></a>组账户说明</h1><h3 id="私有组"><a href="#私有组" class="headerlink" title="私有组"></a>私有组</h3><p>当创建一个用户时没有指定属于哪个组，Linux 就会建立一个与用户同名的私有组，此私有组只含有该用户。</p><h3 id="标准组"><a href="#标准组" class="headerlink" title="标准组"></a>标准组</h3><p>当创建一个用户时可以选定一个标准组，如果一个用户同时属于多个组时，登录后所属的组为主组，其他的为附加组。</p><h1 id="账户系统文件说明"><a href="#账户系统文件说明" class="headerlink" title="账户系统文件说明"></a>账户系统文件说明</h1><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><p>每一行代表一个账号，众多账号是系统正常运行所必须的，例如 bin，nobody 每行定义一个用户账户，此文件对所有用户可读。每行账户包含如下信息：</p><p><code>root:x:0:0:root:/root:/bin/bash</code></p><ul><li><strong>用户名</strong>： 就是账号，用来对应 UID，root UID 是 0。</li><li><strong>口令</strong>： 密码，早期 UNIX 系统密码存在此字段，由于此文件所有用户都可以读取，密码容易泄露，后来这个字段数据就存放到 /etc/shadow 中，这里只能看到 X。</li><li><strong>用户标示号（UID）</strong>： 系统内唯一，root 用户的 UID 为 0，普通用户从 1000 开始，1-999 是系统的标准账户，500-65536 是可登陆账号。</li><li><strong>组标示号（GID）</strong>： 与 /etc/group 相关用来规定组名和 GID 相对应。</li><li><strong>注释</strong>： 注释账号</li><li><strong>宿主目录（主文件夹）</strong>： 用户登录系统后所进入的目录 root 在 /root/itcast</li><li><strong>命令解释器（shell）</strong>： 指定该用户使用的 shell ，默认的是 /bin/bash</li></ul><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><p>为了增加系统的安全性，用户口令通常用 shadow passwords 保护。只有 root 可读。每行包含如下信息：<br><code>root:$6$Reu571.V$Ci/kd.OTzaSGU.TagZ5KjYx2MLzQv2IkZ24E1.yeTT3Pp4o/yniTjus/rRaJ92Z18MVy6suf1W5uxxurqssel.:17465:0:99999:7:::</code></p><ul><li>账号名称： 需要和 /etc/passwd 一致。</li><li>密码： 经过加密，虽然加密，但不表示不会被破解，该文件默认权限如下：<ul><li>rw——- 1 root root 1560 Oct 26 17:20 passwd-</li><li>只有root能都读写</li></ul></li><li>最近修改密码日期：  从1970-1-1起，到用户最后一次更改口令的天数</li><li>密码最小时间间隔： 从1970-1-1起，到用户可以更改口令的天数</li><li>密码最大时间间隔： 从1970-1-1起，必须更改的口令天数</li><li>密码到期警告时间： 在口令过期之前几天通知</li><li>密码到期后账号宽限时间</li><li>密码到期禁用账户时间： 在用户口令过期后到禁用账户的天数</li><li>保留</li></ul><h3 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h3><p>用户组的配置文件</p><p><code>root:x:0:</code></p><ul><li>用户组名称</li><li>用户组密码： 给用户组管理员使用，通常不用</li><li>GID： 用户组的ID</li><li>此用户支持的账号名称： 一个账号可以加入多个用户组，例如想要 itcast 加入 root 这个用户组，将该账号填入该字段即可 root❌0:root, icast 将用户进行分组是 Linux 对用户进行管理及控制访问权限的一种手段。一个中可以有多个用户，一个用户可以同时属于多个组。该文件对所有用户可读。</li></ul><h3 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow"></a>/etc/gshadow</h3><p>该文件用户定义用户组口令，组管理员等信息只有root用户可读。</p><p><code>root:\*::</code></p><ul><li>用户组名</li><li>密码列</li><li>用户组管理员的账号</li><li>用户组所属账号<h3 id="账户管理常用命"><a href="#账户管理常用命" class="headerlink" title="账户管理常用命"></a>账户管理常用命</h3><h4 id="增加用户"><a href="#增加用户" class="headerlink" title="增加用户"></a>增加用户</h4><pre><code>useradd 用户名useradd -u (UID号)useradd -p (口令)useradd -g (分组)useradd -s (SHELL)useradd -d (用户目录)</code></pre></li></ul><p>如：<code>useradd lusifer</code></p><p>增加用户名为 lusifer 的账户</p><h4 id="修改用户"><a href="#修改用户" class="headerlink" title="修改用户"></a>修改用户</h4><pre><code>usermod -u (新UID)usermod -d (用户目录)usermod -g (组名)usermod -s (SHELL)usermod -p (新口令)usermod -l (新登录名)usermod -L (锁定用户账号密码)usermod -U (解锁用户账号)</code></pre><p>如：<code>usermod -u 1024 -g group2 -G root lusifer</code></p><p>将 lusifer 用户 uid 修改为 1024，默认组改为系统中已经存在的 group2，并且加入到系统管理员组</p><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><pre><code>userdel 用户名 (删除用户账号)userdel -r 删除账号时同时删除目录</code></pre><p>如：<code>userdel -r lusifer</code></p><p>删除用户名为 lusifer 的账户并同时删除 lusifer 的用户目录</p><h3 id="组账户维护"><a href="#组账户维护" class="headerlink" title="组账户维护"></a>组账户维护</h3><pre><code>groupadd 组账户名 (创建新组)groupadd -g 指定组GIDgroupmod -g 更改组的GIDgroupmod -n 更改组账户名groupdel 组账户名 (删除指定组账户)</code></pre><h3 id="口令维护"><a href="#口令维护" class="headerlink" title="口令维护"></a>口令维护</h3><pre><code>passwd 用户账户名 (设置用户口令)passwd -l 用户账户名 (锁定用户账户)passwd -u 用户账户名 (解锁用户账户)passwd -d 用户账户名 (删除账户口令)gpasswd -a 用户账户名 组账户名 (将指定用户添加到指定组)gpasswd -d 用户账户名 组账户名 (将用户从指定组中删除)gpasswd -A 用户账户名 组账户名 (将用户指定为组的管理员)</code></pre><h4 id="用户和组状态"><a href="#用户和组状态" class="headerlink" title="用户和组状态"></a>用户和组状态</h4><pre><code>su 用户名(切换用户账户)id 用户名(显示用户的UID，GID)whoami (显示当前用户名称)groups (显示用户所属组)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux LVM 磁盘扩容</title>
      <link href="/2018/08/16/linux-lvm-ci-pan-kuo-rong/"/>
      <url>/2018/08/16/linux-lvm-ci-pan-kuo-rong/</url>
      
        <content type="html"><![CDATA[<h1 id="LVM-的基本概念"><a href="#LVM-的基本概念" class="headerlink" title="LVM 的基本概念"></a>LVM 的基本概念</h1><h3 id="物理卷-Physical-volume-PV"><a href="#物理卷-Physical-volume-PV" class="headerlink" title="物理卷 Physical volume (PV)"></a>物理卷 Physical volume (PV)</h3><p>可以在上面建立卷组的媒介，可以是硬盘分区，也可以是硬盘本身或者回环文件（loopback file）。物理卷包括一个特殊的 header，其余部分被切割为一块块物理区域（physical extents）。</p><h4 id="卷组-Volume-group-VG"><a href="#卷组-Volume-group-VG" class="headerlink" title="卷组 Volume group (VG)"></a>卷组 Volume group (VG)</h4><p>将一组物理卷收集为一个管理单元。</p><h4 id="逻辑卷-Logical-volume-LV"><a href="#逻辑卷-Logical-volume-LV" class="headerlink" title="逻辑卷 Logical volume (LV)"></a>逻辑卷 Logical volume (LV)</h4><p>虚拟分区，由物理区域（physical extents）组成。</p><h4 id="物理区域-Physical-extent-PE"><a href="#物理区域-Physical-extent-PE" class="headerlink" title="物理区域 Physical extent (PE)"></a>物理区域 Physical extent (PE)</h4><p>硬盘可供指派给逻辑卷的最小单位（通常为 4MB）。</p><h1 id="磁盘操作相关命令"><a href="#磁盘操作相关命令" class="headerlink" title="磁盘操作相关命令"></a>磁盘操作相关命令</h1><h4 id="df-h（查看挂载点）"><a href="#df-h（查看挂载点）" class="headerlink" title="df -h（查看挂载点）"></a><code>df -h</code>（查看挂载点）</h4><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/5EF5AB70A7864D6CB778E29F1E49ECE8/1848" alt></p><h4 id="lvdisplay（显示当前的-logical-volume）"><a href="#lvdisplay（显示当前的-logical-volume）" class="headerlink" title="lvdisplay（显示当前的 logical volume）"></a><code>lvdisplay</code>（显示当前的 logical volume）</h4><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/B46A16706BE84D7785ABDEDB2ABC8447/1850" alt></p><p>备注： 注意这里目前有两个，一个是文件系统所在的 volume，另一个是 swap 分区使用的 volume，当然，我们需要扩容的是第一个</p><h4 id="vgdisplay（显示当前的-volume-group）"><a href="#vgdisplay（显示当前的-volume-group）" class="headerlink" title="vgdisplay（显示当前的 volume group）"></a><code>vgdisplay</code>（显示当前的 volume group）</h4><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/28102956E5304EDB9F65AAB4B89F132A/1854" alt></p><h1 id="开始-LVM-扩容"><a href="#开始-LVM-扩容" class="headerlink" title="开始 LVM 扩容"></a>开始 LVM 扩容</h1><h3 id="查看-fdisk"><a href="#查看-fdisk" class="headerlink" title="查看 fdisk"></a>查看 fdisk</h3><pre><code>fdisk -l</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/8F4B442E5D8347AA80C023E193659953/1856" alt></p><p>因为这台机器默认开启了 LVM，所以目前有一个 <code>extended</code>分区和一个<code>LVM</code> 分区，并且他们是完全重叠的。这是因为，LVM 分区作为一个虚拟的分区，完全占用了这个 extended 分区，原理图见下：<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/53A82CC632A94D21A2599C391E79EA61/1858" alt></p><p>因此，现在需要做的就是将 extended partition (<code>sda2</code>) 扩展到最大，然后创建一个新的 LVM logical partition (<code>sda6</code>)，用它来填满 sda2</p><h3 id="查看所有连接到电脑上的储存设备"><a href="#查看所有连接到电脑上的储存设备" class="headerlink" title="查看所有连接到电脑上的储存设备"></a>查看所有连接到电脑上的储存设备</h3><pre><code>disk -l |grep &#39;/dev&#39;</code></pre><h4 id="1-块磁盘效果图"><a href="#1-块磁盘效果图" class="headerlink" title="1 块磁盘效果图"></a>1 块磁盘效果图</h4><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/8E0985A5EA2C46C497CFC5DCB2EAD87B/1860" alt></p><p>2 块磁盘效果图（新增磁盘，尚未挂载）<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/8E87CFC5237D4B0A9E1A6A8805976569/1862" alt></p><h3 id="创建-sdb-分区"><a href="#创建-sdb-分区" class="headerlink" title="创建 sdb 分区"></a>创建 sdb 分区</h3><pre><code>fdisk /dev/sdbn    # 新建分区l    # 选择逻辑分区，如果没有，则首先创建扩展分区（p），然后再添加逻辑分区（硬盘：最多四个分区  P-P-P-P 或 P-P-P-E）</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/93D8E728C55248EE82F285D4F05CA1F6/1864" alt></p><pre><code>回车回车回车w    # 写入磁盘分区</code></pre><h3 id="格式化磁盘"><a href="#格式化磁盘" class="headerlink" title="格式化磁盘"></a>格式化磁盘</h3><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/892B518A557C4A0EB276B13C47321F53/1867" alt></p><pre><code>mkfs -t ext4 /dev/sdb1</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/BA2F4D79A22C44E6BCFA5E65947028D4/1866" alt></p><h3 id="创建-PV"><a href="#创建-PV" class="headerlink" title="创建 PV"></a>创建 PV</h3><pre><code>pvcreate /dev/sdb1</code></pre><h3 id="查看卷组"><a href="#查看卷组" class="headerlink" title="查看卷组"></a>查看卷组</h3><pre><code>pvscan</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/41E6D108CF2F44198EA424D347F7E837/1869" alt></p><h3 id="扩容-VG"><a href="#扩容-VG" class="headerlink" title="扩容 VG"></a>扩容 VG</h3><pre><code>vgdisplay</code></pre><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/706E617A0E414CD98E818626EB74198D/1871" alt></p><pre><code>vgextend ubuntu-vg /dev/sdb1</code></pre><h3 id="扩容-LV"><a href="#扩容-LV" class="headerlink" title="扩容 LV"></a>扩容 LV</h3><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/7679140594AB463E83101E4BC2C55CAA/1873" alt></p><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/81FCD01AD5F64245BE31AABB7D422071/1875" alt></p><pre><code># 增加指定大小lvextend -L +30G /dev/ubuntu-vg/root# 按百分比扩容lvextend -l +100%FREE /dev/ubuntu-vg/root</code></pre><h3 id="刷新分区"><a href="#刷新分区" class="headerlink" title="刷新分区"></a>刷新分区</h3><pre><code>resize2fs /dev/ubuntu-vg/root</code></pre><h3 id="删除-unknown-device"><a href="#删除-unknown-device" class="headerlink" title="删除 unknown device"></a>删除 unknown device</h3><pre><code>pvscanvgreduce --removemissing ubuntu-vg</code></pre><p>注意：不要卸载扩容的磁盘，可能出现丢失数据或是系统无法启动</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装 MySQL</title>
      <link href="/2018/08/12/linux-an-zhuang-mysql/"/>
      <url>/2018/08/12/linux-an-zhuang-mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-安装-MySQL"><a href="#Linux-安装-MySQL" class="headerlink" title="Linux 安装 MySQL"></a>Linux 安装 MySQL</h1><h3 id="更新数据源"><a href="#更新数据源" class="headerlink" title="更新数据源"></a>更新数据源</h3><pre><code>apt-get update</code></pre><h3 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h3><pre><code>apt-get install mysql-server</code></pre><p>系统将提示您在安装过程中创建 root 密码。选择一个安全的密码，并确保你记住它，因为你以后需要它。接下来，我们将完成 MySQL 的配置。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为是全新安装，您需要运行附带的安全脚本。这会更改一些不太安全的默认选项，例如远程 root 登录和示例用户。在旧版本的 MySQL 上，您需要手动初始化数据目录，但 Mysql 5.7 已经自动完成了。</p><p>运行安全脚本：</p><pre><code>mysql_secure_installation</code></pre><p>这将提示您输入您在之前步骤中创建的 root 密码。您可以按 Y，然后 ENTER 接受所有后续问题的默认值，但是要询问您是否要更改 root 密码。您只需在之前步骤中进行设置即可，因此无需现在更改。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>按上边方式安装完成后，MySQL 应该已经开始自动运行了。要测试它，请检查其状态。</p><pre><code>lusifer@ubuntu:~$ systemctl status mysql.service● mysql.service - MySQL Community Server   Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled)   Active: active (running) since Tue 2017-11-21 13:04:34 CST; 3min 24s ago Main PID: 2169 (mysqld)   CGroup: /system.slice/mysql.service           └─2169 /usr/sbin/mysqldNov 21 13:04:33 ubuntu systemd[1]: Starting MySQL Community Server...Nov 21 13:04:34 ubuntu systemd[1]: Started MySQL Community Server.</code></pre><h3 id="查看-MySQL-版本："><a href="#查看-MySQL-版本：" class="headerlink" title="查看 MySQL 版本："></a>查看 MySQL 版本：</h3><pre><code>mysqladmin -p -u root version</code></pre><h1 id="配置远程访问"><a href="#配置远程访问" class="headerlink" title="配置远程访问"></a>配置远程访问</h1><ul><li>修改配置文件<pre><code>nano /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre></li><li>注释掉(语句前面加上 # 即可)：<pre><code>bind-address = 127.0.0.1</code></pre></li><li>重启 MySQL<pre><code>service mysql restart</code></pre></li><li>登录 MySQL<pre><code>mysql -u root -p</code></pre></li><li>授权 root 用户允许所有人连接<pre><code>grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;你的 mysql root 账户密码&#39;;</code></pre></li></ul><h1 id="因弱口令无法成功授权解决步骤"><a href="#因弱口令无法成功授权解决步骤" class="headerlink" title="因弱口令无法成功授权解决步骤"></a>因弱口令无法成功授权解决步骤</h1><ul><li>查看和设置密码安全级别<pre><code>select @@validate_password_policy;</code></pre><pre><code>set global validate_password_policy=0;</code></pre></li><li>查看和设置密码长度限制<pre><code>select @@validate_password_length;</code></pre><pre><code>set global validate_password_length=1;</code></pre></li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>service mysql start</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code>service mysql stop</code></pre><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><pre><code>service mysql restart</code></pre><h1 id="其它配置"><a href="#其它配置" class="headerlink" title="其它配置"></a>其它配置</h1><p>修改配置 <code>mysqld.cnf</code> 配置文件</p><pre><code>vi /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><h3 id="配置默认字符集"><a href="#配置默认字符集" class="headerlink" title="配置默认字符集"></a>配置默认字符集</h3><p>在 <code>[mysqld]</code> 节点上增加如下配置</p><pre><code>[client]default-character-set=utf8</code></pre><p>在 <code>[mysqld]</code>节点底部增加如下配置</p><pre><code>default-storage-engine=INNODBcharacter-set-server=utf8collation-server=utf8_general_ci</code></pre><h3 id="配置忽略数据库大小写敏感"><a href="#配置忽略数据库大小写敏感" class="headerlink" title="配置忽略数据库大小写敏感"></a>配置忽略数据库大小写敏感</h3><p>在 <code>[mysqld]</code>节点底部增加如下配置</p><pre><code>lower-case-table-names = 1</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装 Tomcat</title>
      <link href="/2018/08/12/linux-an-zhuang-tomcat/"/>
      <url>/2018/08/12/linux-an-zhuang-tomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-安装-Tomcat"><a href="#Linux-安装-Tomcat" class="headerlink" title="Linux 安装 Tomcat"></a>Linux 安装 Tomcat</h1><blockquote><p>此处以 Tomcat 8.5.23 为例</p></blockquote><p>下载地址<br><a href="https://tomcat.apache.org/" target="_blank" rel="noopener">https://tomcat.apache.org/</a></p><h1 id="解压缩并移动到指定目录"><a href="#解压缩并移动到指定目录" class="headerlink" title="解压缩并移动到指定目录"></a>解压缩并移动到指定目录</h1><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><pre><code>tar -zxvf apache-tomcat-8.5.23.tar.gz</code></pre><h3 id="变更目录名"><a href="#变更目录名" class="headerlink" title="变更目录名"></a>变更目录名</h3><pre><code>mv apache-tomcat-8.5.23 tomcat</code></pre><h3 id="移动目录"><a href="#移动目录" class="headerlink" title="移动目录"></a>移动目录</h3><pre><code>mv tomcat/ /usr/local/</code></pre><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><pre><code>/usr/local/tomcat/bin/startup.sh</code></pre><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><pre><code>/usr/local/tomcat/bin/shutdown.sh</code></pre><h3 id="目录内执行脚本"><a href="#目录内执行脚本" class="headerlink" title="目录内执行脚本"></a>目录内执行脚本</h3><pre><code>./startup.sh</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 安装 Java</title>
      <link href="/2018/08/12/linux-an-zhuang-java/"/>
      <url>/2018/08/12/linux-an-zhuang-java/</url>
      
        <content type="html"><![CDATA[<blockquote><p>此处以 JDK 1.8.0_152 为例</p></blockquote><h1 id="解压缩并移动到指定目录"><a href="#解压缩并移动到指定目录" class="headerlink" title="解压缩并移动到指定目录"></a>解压缩并移动到指定目录</h1><h3 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h3><pre><code>tar -zxvf jdk-8u152-linux-x64.tar.gz</code></pre><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><pre><code>mkdir -p /usr/local/java</code></pre><h3 id="移动安装包"><a href="#移动安装包" class="headerlink" title="移动安装包"></a>移动安装包</h3><pre><code>mv jdk1.8.0_152/ /usr/local/java/</code></pre><h3 id="设置所有者"><a href="#设置所有者" class="headerlink" title="设置所有者"></a>设置所有者</h3><pre><code>chown -R root:root /usr/local/java/</code></pre><h1 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h1><h3 id="配置系统环境变量"><a href="#配置系统环境变量" class="headerlink" title="配置系统环境变量"></a>配置系统环境变量</h3><pre><code>nano /etc/environment</code></pre><h3 id="添加如下语句"><a href="#添加如下语句" class="headerlink" title="添加如下语句"></a>添加如下语句</h3><pre><code>PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;export JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib</code></pre><h3 id="配置用户环境变量"><a href="#配置用户环境变量" class="headerlink" title="配置用户环境变量"></a>配置用户环境变量</h3><pre><code>nano /etc/profile</code></pre><h3 id="添加如下语句-1"><a href="#添加如下语句-1" class="headerlink" title="添加如下语句"></a>添加如下语句</h3><pre><code>if [ &quot;$PS1&quot; ]; then  if [ &quot;$BASH&quot; ] &amp;&amp; [ &quot;$BASH&quot; != &quot;/bin/sh&quot; ]; then    # The file bash.bashrc already sets the default PS1.    # PS1=&#39;\h:\w\$ &#39;    if [ -f /etc/bash.bashrc ]; then      . /etc/bash.bashrc    fi  else    if [ &quot;`id -u`&quot; -eq 0 ]; then      PS1=&#39;# &#39;    else      PS1=&#39;$ &#39;    fi  fifiexport JAVA_HOME=/usr/local/java/jdk1.8.0_152export JRE_HOME=/usr/local/java/jdk1.8.0_152/jreexport CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/binif [ -d /etc/profile.d ]; then  for i in /etc/profile.d/*.sh; do    if [ -r $i ]; then      . $i    fi  done  unset ifi</code></pre><h3 id="使用户环境变量生效"><a href="#使用户环境变量生效" class="headerlink" title="使用户环境变量生效"></a>使用户环境变量生效</h3><pre><code>source /etc/profile</code></pre><h3 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h3><pre><code>root@UbuntuBase:/usr/local/java# java -versionjava version &quot;1.8.0_152&quot;Java(TM) SE Runtime Environment (build 1.8.0_152-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.152-b16, mixed mode)</code></pre><h3 id="为其他用户更新用户环境变量"><a href="#为其他用户更新用户环境变量" class="headerlink" title="为其他用户更新用户环境变量"></a>为其他用户更新用户环境变量</h3><pre><code>su lusifersource /etc/profile</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 文件权限管理</title>
      <link href="/2018/08/07/linux-wen-jian-quan-xian-guan-li/"/>
      <url>/2018/08/07/linux-wen-jian-quan-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-文件权限管理"><a href="#Linux-文件权限管理" class="headerlink" title="Linux 文件权限管理"></a>Linux 文件权限管理</h1><h3 id="查看文件和目录的权限"><a href="#查看文件和目录的权限" class="headerlink" title="查看文件和目录的权限"></a>查看文件和目录的权限</h3><p>ls –al<code>使用 ls 不带参数只显示文件名称，通过ls –al</code> 可以显示文件或者目录的权限信息。</p><p><code>ls -l 文件名</code> 显示信息包括：文件类型 (<code>d</code> 目录，<code>-</code>普通文件，<code>l</code> 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称</p><p><code>-rw-r--r-- 1 lusifer lusifer 675 Oct 26 17:20 .profile</code></p><ul><li><code>-</code>：普通文件</li><li><code>rw-</code>：说明用户 lusifer 有读写权限，没有运行权限</li><li><code>r--</code>：表示用户组 lusifer 只有读权限，没有写和运行的权限</li><li><code>r--</code>：其他用户只有读权限，没有写权限和运行的权限</li><li><table><thead><tr><th>-rw-r--r--</th><th>1</th><th>lusifer</th><th>lusifer</th><th>675</th><th>Oct 26 17:20</th><th>.profile</th></tr></thead><tbody><tr><td>文档类型及权限</td><td>连接数</td><td>文档所属用户</td><td>文档所属组</td><td>文档大小</td><td>文档最后被修改日期</td><td>文档名称</td></tr></tbody></table></li></ul><table><thead><tr><th>-</th><th>rw-</th><th>r--</th><th>r--</th></tr></thead><tbody><tr><td>文档类型</td><td>文档所有者权限（user）</td><td>文档所属用户组权限（group）</td><td>其他用户权限（other）</td></tr></tbody></table><h3 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h3><ul><li><code>d</code> 表示目录</li><li><code>l</code> 表示软连接</li><li><code>–</code> 表示文件</li><li><code>c</code> 表示串行端口字符设备文件</li><li><code>b</code>  表示可供存储的块设备文件<br>余下的字符 3 个字符为一组。<code>r</code>只读，<code>w</code> 可写，<code>x</code> 可执行，<code>-</code> 表示无此权限</li></ul><h3 id="连接数"><a href="#连接数" class="headerlink" title="连接数"></a>连接数</h3><p>指有多少个文件指向同一个索引节点。</p><h3 id="文档所属用户和所属组"><a href="#文档所属用户和所属组" class="headerlink" title="文档所属用户和所属组"></a>文档所属用户和所属组</h3><p>就是文档属于哪个用户和用户组。文件所属用户和组是可以更改的</p><h3 id="文档大小"><a href="#文档大小" class="headerlink" title="文档大小"></a>文档大小</h3><p>默认是 bytes</p><h1 id="更改操作权限"><a href="#更改操作权限" class="headerlink" title="更改操作权限"></a>更改操作权限</h1><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组</p><p><code>chown [-R] 用户名称 文件或者目录</code></p><p><code>chown [-R] 用户名称 用户组名称 文件或目录</code>  </p><p>-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变访问权限</p><p><code>chmod [who] [+ | - | =] [mode] 文件名</code></p><h3 id="who"><a href="#who" class="headerlink" title="who"></a>who</h3><p>表示操作对象可以是以下字母的一个或者组合</p><ul><li>u：用户 user</li><li>g：用户组 group</li><li>o：表示其他用户</li><li>a：表示所有用户是系统默认的<h3 id="操作符号"><a href="#操作符号" class="headerlink" title="操作符号"></a>操作符号</h3></li><li>+：表示添加某个权限</li><li>-：表示取消某个权限</li><li>=：赋予给定的权限，取消文档以前的所有权限<h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3>表示可执行的权限，可以是 r、w、x</li></ul><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><p>文件名可以使空格分开的文件列表</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>lusifer@UbuntuBase:~$ ls -al test.txt -rw-rw-r-- 1 lusifer lusifer 6 Nov  2 21:47 test.txtlusifer@UbuntuBase:~$ chmod u=rwx,g+r,o+r test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrw-r-- 1 lusifer lusifer 6 Nov  2 21:47 test.txtlusifer@UbuntuBase:~$</code></pre><h3 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h3><p>数字设定法中数字表示的含义</p><ul><li>0 表示没有任何权限</li><li>1 表示有可执行权限 = x</li><li>2 表示有可写权限 = w</li><li>4 表示有可读权限 = r<br>也可以用数字来表示权限如 chmod 755 file_name</li></ul><table><thead><tr><th>r w x</th><th>r – x</th><th>r - x</th></tr></thead><tbody><tr><td>4 2 1</td><td>4 - 1</td><td>4 - 1</td></tr><tr><td>user</td><td>group</td><td>others</td></tr></tbody></table><p>若要 rwx 属性则 4+2+1=7</p><p>若要 rw- 属性则 4+2=6</p><p>若要 r-x 属性则 4+1=5</p><pre><code>lusifer@UbuntuBase:~$ chmod 777 test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrwxrwx 1 lusifer lusifer 6 Nov  2 21:47 test.txtlusifer@UbuntuBase:~$ chmod 770 test.txt lusifer@UbuntuBase:~$ ls -al test.txt -rwxrwx--- 1 lusifer lusifer 6 Nov  2 21:47 test.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux软件包管理</title>
      <link href="/2018/08/05/linux-ruan-jian-bao-guan-li/"/>
      <url>/2018/08/05/linux-ruan-jian-bao-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-软件包管理"><a href="#Linux-软件包管理" class="headerlink" title="Linux 软件包管理"></a>Linux 软件包管理</h1><p>APT(Advanced Packaging Tool) 是 Debian/Ubuntu 类 Linux 系统中的软件包管理程序, 使用它可以找到想要的软件包, 而且安装、卸载、更新都很简便；也可以用来对 Ubuntu 进行升级; APT 的源文件为 <code>/etc/apt/</code> 目录下的<code>sources.list</code>文件。</p><h1 id="修改数据源"><a href="#修改数据源" class="headerlink" title="修改数据源"></a>修改数据源</h1><p>由于国内的网络环境问题，我们需要将 Ubuntu 的数据源修改为国内数据源，操作步骤如下：</p><h3 id="查看系统版本"><a href="#查看系统版本" class="headerlink" title="查看系统版本"></a>查看系统版本</h3><pre><code>lsb_release -a</code></pre><p>输出结果为</p><pre><code>No LSB modules are available.Distributor ID:    UbuntuDescription:    Ubuntu 16.04 LTSRelease:    16.04Codename:    xenial</code></pre><p>注意： Codename 为 <code>xenial</code>，该名称为我们 Ubuntu 系统的名称，修改数据源需要用到该名称</p><h3 id="编辑数据源"><a href="#编辑数据源" class="headerlink" title="编辑数据源"></a>编辑数据源</h3><pre><code>vi /etc/apt/sources.list</code></pre><p>删除全部内容并修改为</p><pre><code>deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</code></pre><h3 id="更新数据源"><a href="#更新数据源" class="headerlink" title="更新数据源"></a>更新数据源</h3><pre><code>apt-get update</code></pre><h3 id="常用-APT-命令"><a href="#常用-APT-命令" class="headerlink" title="常用 APT 命令"></a>常用 APT 命令</h3><p>安装软件包</p><pre><code>apt-get install packagename</code></pre><p>删除软件包</p><pre><code>apt-get remove packagename</code></pre><p>更新软件包列表</p><pre><code>apt-get update</code></pre><p>升级有可用更新的系统（慎用）</p><pre><code>apt-get upgrade</code></pre><h1 id="其它-APT-命令"><a href="#其它-APT-命令" class="headerlink" title="其它 APT 命令"></a>其它 APT 命令</h1><p>搜索</p><pre><code>apt-cache search package</code></pre><p>获取包信息</p><pre><code>apt-cache show package</code></pre><p>删除包及配置文件</p><pre><code>apt-get remove package --purge</code></pre><p>了解使用依赖</p><pre><code>apt-cache depends package</code></pre><p>查看被哪些包依赖</p><pre><code>apt-cache rdepends package</code></pre><p>安装相关的编译环境</p><pre><code>apt-get build-dep package</code></pre><p>下载源代码</p><pre><code>apt-get source package</code></pre><p>清理无用的包</p><pre><code>apt-get clean &amp;&amp; apt-get autoclean</code></pre><p>检查是否有损坏的依赖</p><pre><code>apt-get check</code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Xshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详细的Linux基本操作</title>
      <link href="/2018/08/02/linux-yuan-cheng-kong-zhi-guan-li/"/>
      <url>/2018/08/02/linux-yuan-cheng-kong-zhi-guan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-远程控制管理"><a href="#Linux-远程控制管理" class="headerlink" title="Linux 远程控制管理"></a>Linux 远程控制管理</h1><p>传统的网络服务程序，FTP、POP、telnet 本质上都是不安全的，因为它们在网络上通过明文传送口令和数据，这些数据非常容易被截获。SSH 叫做 <code>Secure Shell</code>。通过 SSH，可以把传输数据进行加密，预防攻击，传输的数据进行了压缩，可以加快传输速度。</p><h1 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h1><p>SSH 是芬兰一家公司开发。但是受到版权和加密算法限制，现在很多人都使用 OpenSSH。OpenSSH 是 SSH 的替代软件，免费。</p><p>OpenSSH 由客户端和服务端组成。</p><ul><li>基于口令的安全验证：知道服务器的帐号密码即可远程登录，口令和数据在传输过程中都会被加密。</li><li>基于密钥的安全验证：此时需要在创建一对密钥，把公有密钥放到远程服务器上自己的宿主目录中，而私有密钥则由自己保存。</li><li><h3 id="检查软件是否安装"><a href="#检查软件是否安装" class="headerlink" title="检查软件是否安装"></a>检查软件是否安装</h3><pre><code>apt-cache policy openssh-client openssh-server</code></pre></li></ul><h3 id="安装服务端"><a href="#安装服务端" class="headerlink" title="安装服务端"></a>安装服务端</h3><p><code>apt-get install openssh-server</code></p><h3 id="安装客户端"><a href="#安装客户端" class="headerlink" title="安装客户端"></a>安装客户端</h3><p><code>apt-get install openssh-client</code></p><p>OpenSSH 服务器的主要配置文件为 <code>/etc/ssh/sshd\_config</code>，几乎所有的配置信息都在此文件中。</p><h1 id="XShell"><a href="#XShell" class="headerlink" title="XShell"></a>XShell</h1><p>XShell 是一个强大的安全终端模拟软件，它支持 SSH1, SSH2, 以及 Microsoft Windows 平台的 TELNET 协议。XShell 通过互联网到远程主机的安全连接以及它创新性的设计和特色帮助用户在复杂的网络环境中享受他们的工作。<br><a href="http://www.onlinedown.net/soft/36383.htm" target="_blank" rel="noopener">下载Xshell</a><br>XShell 可以在 Windows 界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。</p><p>效果图如下：<img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/A104A5BEC09149258E491DE359AAECAD/1840" alt></p><h1 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h1><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/A40B4D2E3640437485CA4BA0C0F7FCF3/1846" alt></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)</td></tr><tr><td>boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>dev</td><td>用于存放设备文件</td></tr><tr><td>etc</td><td>存放系统配置文件</td></tr><tr><td>home</td><td>存放所有用户文件的根目录</td></tr><tr><td>lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr><td>mnt</td><td>系统管理员安装临时文件系统的安装点</td></tr><tr><td>opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>proc</td><td>虚拟文件系统，存放当前内存的映射</td></tr><tr><td>root</td><td>超级用户目录</td></tr><tr><td>sbin</td><td>存放二进制可执行文件，只有root才能访问</td></tr><tr><td>tmp</td><td>用于存放各种临时文件</td></tr><tr><td>usr</td><td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td></tr><tr><td>var</td><td>用于存放运行时需要改变数据的文件</td></tr></tbody></table><h1 id="Linux-操作文件目录"><a href="#Linux-操作文件目录" class="headerlink" title="Linux 操作文件目录"></a>Linux 操作文件目录</h1><table><thead><tr><th>命令</th><th>说明</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>ls</td><td>显示文件和目录列表</td><td>ls [-alrtAFR] [name...]</td><td></td><td></td></tr><tr><td>-l</td><td>列出文件的详细信息</td><td></td><td></td><td></td></tr><tr><td>-a</td><td>列出当前目录所有文件，包含隐藏文件</td><td></td><td></td><td></td></tr><tr><td>mkdir</td><td>创建目录</td><td>mkdir [-p] dirName</td><td></td><td></td></tr><tr><td>-p</td><td>父目录不存在情况下先生成父目录</td><td></td><td></td><td></td></tr><tr><td>cd</td><td>切换目录</td><td>cd [dirName]</td><td></td><td></td></tr><tr><td>touch</td><td>生成一个空文件</td><td></td><td></td><td></td></tr><tr><td>echo</td><td>生成一个带内容文件</td><td>echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td><td></td><td></td></tr><tr><td>cat</td><td>显示文本文件内容</td><td>cat [-AbeEnstTuv] [--help] [--version] fileName</td><td></td><td></td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp [options] source dest</td><td></td><td></td></tr><tr><td>rm</td><td>删除文件</td><td>rm [options] name...</td><td></td><td></td></tr><tr><td>-f</td><td>强制删除文件或目录</td><td></td><td></td><td></td></tr><tr><td>-r</td><td>同时删除该目录下的所有文件</td><td></td><td></td><td></td></tr><tr><td>mv</td><td>移动文件或目录</td><td>mv [options] source dest</td><td></td><td></td></tr><tr><td>find</td><td>在文件系统中查找指定的文件</td><td></td><td>-name</td><td>文件名</td></tr><tr><td>grep</td><td>在指定的文本文件中查找指定的字符串</td><td></td><td></td><td></td></tr><tr><td>tree</td><td>用于以树状图列出目录的内容</td><td></td><td></td><td></td></tr><tr><td>pwd</td><td>显示当前工作目录</td><td></td><td></td><td></td></tr><tr><td>ln</td><td>建立软链接</td><td></td><td></td><td></td></tr><tr><td>more</td><td>分页显示文本文件内容</td><td></td><td></td><td></td></tr><tr><td>head</td><td>显示文件开头内容</td><td></td><td></td><td></td></tr><tr><td>tail</td><td>显示文件结尾内容</td><td></td><td>-f</td><td>跟踪输出</td></tr></tbody></table><h1 id="Linux-操作文件目录-1"><a href="#Linux-操作文件目录-1" class="headerlink" title="Linux 操作文件目录"></a>Linux 操作文件目录</h1><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>stat</td><td>显示指定文件的相关信息,比ls命令显示内容更多</td></tr><tr><td>who</td><td>显示在线登录用户</td></tr><tr><td>hostname</td><td>显示主机名称</td></tr><tr><td>uname</td><td>显示系统信息</td></tr><tr><td>top</td><td>显示当前系统中耗费资源最多的进程</td></tr><tr><td>ps</td><td>显示瞬间的进程状态</td></tr><tr><td>du</td><td>显示指定的文件（目录）已使用的磁盘空间的总量</td></tr><tr><td>df</td><td>显示文件系统磁盘空间的使用情况</td></tr><tr><td>free</td><td>显示当前内存和交换空间的使用情况</td></tr><tr><td>ifconfig</td><td>显示网络接口信息</td></tr><tr><td>ping</td><td>测试网络的连通性</td></tr><tr><td>netstat</td><td>显示网络状态信息</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>kill</td><td>杀死一个进程</td></tr></tbody></table><h1 id="Linux-开关机命令"><a href="#Linux-开关机命令" class="headerlink" title="Linux 开关机命令"></a>Linux 开关机命令</h1><p>shutdown 命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p><p>| 命令          | 语法  参数说明 |<br>|————-|———————————————————|—-|——|<br>| shutdown    | shutdown [-t seconds] [-rkhncfF] time [message] |<br>| -t seconds | 设定在几秒钟之后进行关机程序                                          |<br>| -k         | 并不会真的关机，只是将警告讯息传送给所有只用者                                 |<br>| -r         | 关机后重新开机（重启）                                             |<br>| -h         | 关机后停机                                                   |<br>| -n         | 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机                        |<br>| -c         | 取消目前已经进行中的关机动作                                          |<br>| -f         | 关机时，不做 fcsk 动作(检查 Linux 档系统)                          |<br>| -F         | 关机时，强迫进行 fsck 动作                                        |<br>| time        | 设定关机的时间                                                 |<br>| message     | 传送给所有使用者的警告讯息                                           |</p><h1 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h1><ul><li>reboot</li><li>shutdown -r now<h1 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h1></li><li>shutdown -h now</li></ul><h1 id="Linux-压缩命令"><a href="#Linux-压缩命令" class="headerlink" title="Linux 压缩命令"></a>Linux 压缩命令</h1><h1 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h1><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td></td><td></td><td>tar</td><td>tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</td></tr><tr><td></td><td></td><td>-c</td><td>建立一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-x</td><td>解开一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-z</td><td>是否需要用 gzip 压缩</td></tr><tr><td></td><td></td><td>-j</td><td>是否需要用 bzip2 压缩</td></tr><tr><td></td><td></td><td>-v</td><td>压缩的过程中显示文件</td></tr><tr><td></td><td></td><td>-f</td><td>使用档名，在 f 之后要立即接档名</td></tr><tr><td></td><td></td><td>-tf</td><td>查看归档文件里面的文件</td></tr><tr><td><strong>例子</strong>：</td><td></td><td></td><td></td></tr></tbody></table><ul><li>压缩文件夹：<code>tar -zcvf test.tar.gz test\</code></li><li>解压文件夹：<code>tar -zxvf test.tar.gz</code><h1 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h1></li></ul><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td></td><td></td><td>gzip</td><td>gzip [选项] 压缩（解压缩）的文件名</td></tr><tr><td></td><td></td><td>-d</td><td>解压缩</td></tr><tr><td></td><td></td><td>-l</td><td>对每个压缩文件，显示压缩文件的大小，未压缩文件的大小，压缩比，未压缩文件的名字</td></tr><tr><td></td><td></td><td>-v</td><td>对每一个压缩和解压的文件，显示文件名和压缩比</td></tr><tr><td></td><td></td><td>-num</td><td>用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6</td></tr></tbody></table><p>说明：压缩文件后缀为 gz</p><h1 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h1><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>bzip2</td><td>bzip2 [-cdz]</td><td></td><td></td></tr><tr><td></td><td></td><td>-d</td><td>解压缩</td></tr><tr><td></td><td></td><td>-z</td><td>压缩参数</td></tr><tr><td></td><td></td><td>-num</td><td>用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6</td></tr></tbody></table><p>说明：压缩文件后缀为 bz2</p><h1 id="Linux-编辑器"><a href="#Linux-编辑器" class="headerlink" title="Linux 编辑器"></a>Linux 编辑器</h1><p>vim</p><p>#运行模式<br>编辑模式：等待编辑命令输入</p><p>插入模式：编辑模式下，输入 <code>i</code> 进入插入模式，插入文本信息</p><p>命令模式：在编辑模式下，输入<code>:</code> 进行命令模式</p><p>#命令<br><code>:q</code>直接退出vi</p><p><code>:wq</code>保存后退出vi ，并可以新建文件</p><p><code>:q!</code> 强制退出</p><p><code>:w file</code> 将当前内容保存成某个文件</p><p><code>:set number</code> 在编辑文件显示行号</p><p><code>:set nonumber</code> 在编辑文件不显示行号</p><h1 id="nano"><a href="#nano" class="headerlink" title="nano"></a>nano</h1><p>nano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ul><li>保存：ctrl + o</li><li>搜索：ctrl + w</li><li>上一页：ctrl + y</li><li>下一页：ctrl + v</li><li>退出：ctrl + x</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Xshell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux简介</title>
      <link href="/2018/08/01/linux-jian-jie/"/>
      <url>/2018/08/01/linux-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 <code>Linux 内核</code>。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 <code>Linux</code> 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 <code>Linux</code> 操作系统</p><p>Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution</p><p>目前市面上较知名的发行版有：<code>Ubuntu</code>、RedHat、<code>CentOS</code>、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p><h1 id="Linux-与-Windows-比较"><a href="#Linux-与-Windows-比较" class="headerlink" title="Linux 与 Windows 比较"></a>Linux 与 Windows 比较</h1><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下:</p><table><thead><tr><th>比较</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>界面</td><td>界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td><td>图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td>驱动程序</td><td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td><td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在 Windows 下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td></tr><tr><td>使用</td><td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td><td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td></tr><tr><td>学习</td><td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td><td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td></tr><tr><td>软件</td><td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td><td>大部分软件都可以自由获取，同样功能的软件选择较少。</td></tr></tbody></table><h1 id="安装-Ubuntu-Server"><a href="#安装-Ubuntu-Server" class="headerlink" title="安装 Ubuntu Server"></a>安装 Ubuntu Server</h1><p><a href="https://ubuntu.com/download" target="_blank" rel="noopener">下载 Ubuntu Server</a></p><h1 id="安装-VMware"><a href="#安装-VMware" class="headerlink" title="安装 VMware"></a>安装 VMware</h1><p><a href="https://leblog.github.io/2018/03/18/vmware-workstation-pro-15-xia-zai/" target="_blank" rel="noopener">安装虚拟机</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA小知识总结</title>
      <link href="/2018/07/21/java-xiao-zhi-shi-zong-jie/"/>
      <url>/2018/07/21/java-xiao-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="equals-与-的区别"><a href="#equals-与-的区别" class="headerlink" title="equals 与 == 的区别"></a>equals 与 == 的区别</h1><ul><li><code>==</code>与<code>equals</code>的主要区别是：<code>==</code> 常用于比较原生类型，而 <code>equals()</code> 方法用于检查对象的相等性。</li><li>另一个不同的点是：如果 <code>==</code>和 <code>equals()</code> 用于比较对象，当两个引用地址相同，<code>==</code> 返回 true。而 <code>equals()</code> 可以返回 true 或者 false 主要取决于重写实现。最常见的一个例子，字符串的比较，不同情况 <code>==</code> 和 <code>equals()</code> 返回不同的结果。</li></ul><h1 id="session-与-cookie-区别"><a href="#session-与-cookie-区别" class="headerlink" title="session 与 cookie 区别"></a>session 与 cookie 区别</h1><ul><li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li><li>cookie 不是很安全，别人可以分析存放在本地的 - cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。</li><li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。</li><li>单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。    </li></ul><h1 id="final-finally-finalize-的区别"><a href="#final-finally-finalize-的区别" class="headerlink" title="final, finally, finalize 的区别"></a>final, finally, finalize 的区别</h1><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承.</p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>是异常处理语句结构的一部分，表示总是执行.</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.</p><h1 id="int-和-Integer-有什么区别"><a href="#int-和-Integer-有什么区别" class="headerlink" title="int 和 Integer 有什么区别"></a>int 和 Integer 有什么区别</h1><p>int 是 Java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 Java 为 int 提供的封装类。 int 的默认值为 <code>0</code>，而 Integer 的默认值为 <code>null</code>，是引用类型，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无法表达出未赋值的情况， Java 中 int 和 Integer 关系是比较微妙的。关系如下：</p><ul><li>int 是基本的数据类型；</li><li>Integer 是 int 的封装类；</li><li>int 和 Integer 都可以表示某一个数值；</li><li>int 和 Integer 不能够互用，因为他们两种不同的数据类型；</li></ul><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><h3 id="重载-Overload"><a href="#重载-Overload" class="headerlink" title="重载 Overload"></a>重载 Overload</h3><p>表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。</p><h3 id="重写-Override"><a href="#重写-Override" class="headerlink" title="重写 Override"></a>重写 Override</h3><p>表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法。</p><h1 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="headerlink" title="抽象类和接口有什么区别"></a>抽象类和接口有什么区别</h1><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>默认的方法实现</td><td>它可以有默认的方法实现</td><td>接口完全是抽象的。它根本不存在方法的实现</td></tr><tr><td>实现</td><td>子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td><td>子类使用关键字 implements 来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>与正常 Java 类的区别</td><td>除了你不能实例化抽象类之外，它和普通Java类没有任何区别</td><td>接口是完全不同的类型</td></tr><tr><td>访问修饰符</td><td>抽象方法可以有 public、protected 和 default 这些修饰符</td><td>接口方法默认修饰符是 public。你不可以使用其它修饰符。</td></tr><tr><td>main 方法</td><td>抽象方法可以有 main 方法并且我们可以运行它</td><td>接口没有 main 方法，因此我们不能运行它。</td></tr><tr><td>多继承</td><td>抽象方法可以继承一个类和实现多个接口</td><td>接口只可以继承一个或多个其它接口</td></tr><tr><td>速度</td><td>它比接口速度要快</td><td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。</td></tr><tr><td>添加新方法</td><td>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。</td><td>如果你往接口中添加方法，那么你必须改变实现该接口的类。</td></tr></tbody></table><h1 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h1><p>面向对象的三个基本特征是：<code>封装</code>、<code>继承</code>、<code>多态</code>。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 实现多态，有二种方式，覆盖，重载。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 请求的 GET 与 POST 方式的区别</title>
      <link href="/2018/07/16/http-qing-qiu-de-get-yu-post-fang-shi-de-qu-bie/"/>
      <url>/2018/07/16/http-qing-qiu-de-get-yu-post-fang-shi-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP-请求的-GET-与-POST-方式的区别"><a href="#HTTP-请求的-GET-与-POST-方式的区别" class="headerlink" title="HTTP 请求的 GET 与 POST 方式的区别"></a>HTTP 请求的 GET 与 POST 方式的区别</h1><blockquote><p>GET和POST是什么？HTTP协议中的两种发送请求的方法。</p></blockquote><blockquote><p>HTTP是什么？HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。</p></blockquote><ul><li>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。</li></ul><ul><li>GET和POST本质上就是TCP链接，并无差别。</li></ul><h3 id="GET和POST还有一个重大区别："><a href="#GET和POST还有一个重大区别：" class="headerlink" title="GET和POST还有一个重大区别："></a>GET和POST还有一个重大区别：</h3><ul><li>GET产生一个TCP数据包；POST产生两个TCP数据包。</li></ul><h3 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子:"></a>小栗子:</h3><ul><li><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p></li><li><p>对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p></li></ul><p>因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？</p><ol><li><p>GET与POST都有自己的语义，不能随便混用。</p></li><li><p>据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。</p></li><li><p>并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。</p></li></ol><p><strong>官方说法：</strong></p><blockquote><ul><li>根据 HTTP 规范，GET 用于信息获取，而且应该是安全的和幂等的。</li><li>根据 HTTP 规范，POST 表示可能修改变服务器上的资源的请求。</li><li>首先是 “GET 方式提交的数据最多只能是 1024 字节”，因为 GET 是通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对 URL 长度的限制是 2083 字节(2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。注意这是限制是整个 URL 长度，而不仅仅是你的参数值数据长度。</li><li>POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK8的新特性</title>
      <link href="/2018/07/09/jdk8-de-xin-te-xing/"/>
      <url>/2018/07/09/jdk8-de-xin-te-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="JDK8-新特性"><a href="#JDK8-新特性" class="headerlink" title="JDK8 新特性"></a>JDK8 新特性</h1><p>以下列出两点重要特性：</p><ul><li><p>Lambda 表达式（匿名函数）</p></li><li><p>Stream 多线程并行数据处理（重要）</p><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1></li><li><p>接口的默认方法只需要使用 <code>default</code> 关键字即可，这个特征又叫做 扩展方法</p></li><li><p>Lambda 表达式</p></li><li><p>Functional 接口  <strong>函数式接口</strong> 是指仅仅只包含一个抽象方法的接口，每一个该类型的 Lambda 表达式都会被匹配到这个抽象方法。你只需要给你的接口添加 <code>@FunctionalInterface</code> 注解</p></li><li><p>使用 <code>::</code> 双冒号关键字来传递方法(静态方法和非静态方法)</p></li><li><p>Predicate 接口和 Lambda 表达式</p></li><li><p>Function 接口</p><ul><li>Function 有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法</li><li>compose 方法表示在某个方法之前执行</li><li>andThen 方法表示在某个方法之后执行</li><li>注意：compose 和 andThen 方法调用之后都会把对象自己本身返回，这可以 <strong>方便链式编程</strong></li></ul></li><li><p>Supplier 接口，返回一个任意范型的值，和 Function 接口不同的是该接口 <strong>没有任何参数</strong></p></li><li><p>Consumer 接口，接收一个任意范型的值，和 Function 接口不同的是该接口 <strong>没有任何值</strong></p></li><li><p>Optional 类</p><ul><li>Optional 不是接口而是一个类，这是个用来防止 <code>NullPointerException</code> 异常的辅助类型</li><li>Optional 被定义为一个简单的容器，其值可能是 null 或者不是 null。</li><li>在 Java8 之前一般某个函数应该返回非空对象但是偶尔却可能返回了 null，而在 Java8 中，不推荐你返回 null 而是返回 Optional。</li><li>这是一个可以为 null 的容器对象。</li><li>如果值存在则 <code>isPresent()</code> 方法会返回 true，调用 <code>get()</code> 方法会返回该对象。<h1 id="小栗子"><a href="#小栗子" class="headerlink" title="小栗子"></a>小栗子</h1><pre><code>package com.lele.jdk8.feature.lambda;</code></pre></li></ul></li></ul><p>import java.util.Arrays;<br>import java.util.List;<br>import java.util.stream.Collectors;</p><p>/**</p><ul><li><p>Lambda 基本用法</p></li><li><p>Title: BaseLambda</p></li><li><p>Description: </p></li><li></li><li><p>@author Lusifer</p></li><li><p>@version 1.0.0</p></li><li><p>@date 2019/1/6 10:42</p></li><li><p>/<br>public class BaseLambda {<br>  public static void main(String[] args) {</p><pre><code>  testForeach();  testStreamDuplicates();</code></pre><p>  }</p><p>  /**</p><ul><li><p>Lambda 遍历</p></li><li><p>/<br>public static void testForeach() {<br>  // 定义一个数组<br>  String[] array = {</p><pre><code>      &quot;尼尔机械纪元&quot;,      &quot;关于我转生成为史莱姆这件事&quot;,      &quot;实力至上主义教师&quot;,      &quot;地狱少女&quot;</code></pre><p>  };</p><p>  // 转换成集合<br>  List<string> acgs = Arrays.asList(array);</string></p><p>  // 传统的遍历方式<br>  System.out.println(“传统的遍历方式：”);<br>  for (String acg : acgs) {</p><pre><code>  System.out.println(acg);</code></pre><p>  }<br>  System.out.println();</p><p>  // 使用 Lambda 表达式以及函数操作(functional operation)<br>  System.out.println(“Lambda 表达式以及函数操作：”);<br>  acgs.forEach((acg) -&gt; System.out.println(acg));<br>  System.out.println();</p><p>  // 在 Java 8 中使用双冒号操作符(double colon operator)<br>  System.out.println(“使用双冒号操作符：”);<br>  acgs.forEach(System.out::println);<br>  System.out.println();<br>}</p><p>/**</p></li><li><p>Stream 去重复</p></li><li><p>String 和 Integer 可以使用该方法去重</p></li><li><p>/<br>public static void testStreamDuplicates() {<br>  System.out.println(“Stream 去重复：”);</p><p>  // 定义一个数组<br>  String[] array = {</p><pre><code>      &quot;尼尔机械纪元&quot;,      &quot;尼尔机械纪元&quot;,      &quot;关于我转生成为史莱姆这件事&quot;,      &quot;关于我转生成为史莱姆这件事&quot;,      &quot;实力至上主义教师&quot;,      &quot;实力至上主义教师&quot;,      &quot;地狱少女&quot;,      &quot;地狱少女&quot;</code></pre><p>  };</p><p>  // 转换成集合<br>  List<string> acgs = Arrays.asList(array);</string></p><p>  // Stream 去重复<br>  acgs = acgs.stream().distinct().collect(Collectors.toList());</p><p>  // 打印<br>  acgs.forEach(System.out::println);<br>}<br>}<br>```</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 博客部署到腾讯云教程</title>
      <link href="/2018/07/03/hexo-bo-ke-bu-shu-dao-teng-xun-yun-jiao-cheng/"/>
      <url>/2018/07/03/hexo-bo-ke-bu-shu-dao-teng-xun-yun-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>本文首发于我的个人博客：<a href="leblog.github.io">乐乐的博客</a></li><li>文章链接：<a href>传送门</a></li></ul></blockquote><blockquote><p>本篇内容用来讲述如何将 hexo 博客部署到腾讯云的服务器上。<br>只要通过三步即可成功部署：</p><ul><li>云服务器端 git 的配置</li><li>Nginx 的配置</li><li>本地端 hexo 的设置更改</li></ul></blockquote><p>下面开始正式讲解如何部署。</p><p><strong>前期需要准备</strong>：</p><ul><li>一个腾讯云服务器</li><li>hexo 本地博客</li></ul><p>顺便说下我的服务器环境：<br>| 操作系统            | CPU | 内存  | 带宽    |<br>|—————–|—–|—–|——-|<br>| CentOS 7.2 64位 | 1核  | 2GB | 1Mbps |</p><h1 id="1-进入云服务器中"><a href="#1-进入云服务器中" class="headerlink" title="1. 进入云服务器中"></a>1. 进入云服务器中</h1><ul><li>首先点击下边网站，登录你的进入云服务器的控制台<br>腾讯云服务器的控制台：<a href="https://console.cloud.tencent.com/cvm/index" target="_blank" rel="noopener">https://console.cloud.tencent.com/cvm/index</a></li></ul><p><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/864802B7DBE0495F912DBFCD76517FFE/1290" alt></p><ul><li>左边菜单选择云主机，然后找到你的服务器。点击登录<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/8C43CC8C4D3D456F96D1C0FC5704994E/1291" alt></li><li>输入密码，进入 云服务器 CentOS中。（初始密码在控制台右上角的消息列表中）<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/19E9FE5BE3B647C7AB13DA3559D22D24/1289" alt></li></ul><h1 id="2-云服务器端配置-git"><a href="#2-云服务器端配置-git" class="headerlink" title="2. 云服务器端配置 git"></a>2. 云服务器端配置 git</h1><p>1.安装依赖库和编译工具</p><ul><li><p>安装依赖库：</p><blockquote><p>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel </p></blockquote></li><li><p>安装编译工具：</p><blockquote><p>yum install gcc perl-ExtUtils-MakeMaker package</p></blockquote></li></ul><p>2.下载git</p><ul><li>选择一个目录来存放下载下来的git安装包。这里选择了<code>/usr/local/src</code>目录</li></ul><blockquote><p> cd /usr/local/src</p></blockquote><ul><li>到官网找一个新版稳定的源码包下载到 <code>/usr/local/src</code> 文件夹里</li></ul><blockquote><p>wget <a href="https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz" target="_blank" rel="noopener">https://www.kernel.org/pub/software/scm/git/git-2.16.2.tar.gz</a></p></blockquote><ul><li><p>解压编译 git</p></li><li><p>在当前目录下解压 <code>git-2.16.2.tar.gz</code></p></li></ul><blockquote><p>tar -zvxf git-2.16.2.tar.gz</p></blockquote><ul><li>进入 git-2.16.2.tar.gz 目录下</li></ul><blockquote><p>cd git-2.16.2</p></blockquote><ul><li>执行编译</li></ul><blockquote><p>make all prefix=/usr/local/git</p></blockquote><ul><li>安装 git 到 <code>/usr/local/git</code> 目录下</li></ul><blockquote><p>make install prefix=/usr/local/git</p></blockquote><p>4.配置 git 环境变量</p><ul><li>将 git 加入 PATH 目录中</li></ul><blockquote><p>echo ‘export PATH=$PATH:/usr/local/git/bin’ &gt;&gt; /etc/bashrc</p></blockquote><ul><li>使 git 环境变量生效</li></ul><blockquote><p>source /etc/bashrc</p></blockquote><p>5.查看 git 版本</p><blockquote><p>git –version</p></blockquote><p>如果此时能查看到 git 的版本号，说明我们已经安装成功了。</p><p>6.创建 git 仓库，用于存放博客网站资源。</p><ul><li>在 <code>home/git</code> 的目录下，创建一个名为<code>hexoBlog</code>的裸仓库（bare repo）。<br>如果没有 <code>home/git</code> 目录，需要先创建；然后修改目录的所有权和用户权限。</li></ul><blockquote><p>mkdir /home/git/<br><br>chown -R $USER:$USER /home/git/<br><br>chmod -R 755 /home/git/</p></blockquote><p>然后，执行如下命令：</p><blockquote><p>cd /home/git/<br><br>git init –bare hexoBlog.git</p></blockquote><p>刚才这一步主要创建一个裸的 git 仓库。</p><p>7.创建一个新的 git 钩子，用于自动部署。</p><ul><li>在 <code>/home/git/hexoBlog.git</code> 下，有一个自动生成的<code>hooks</code> 文件夹。我们需要在里边新建一个新的钩子文件 <code>post-receive</code>。</li></ul><blockquote><p>vim /home/git/hexoBlog.git/hooks/post-receive</p></blockquote><p>按 <code>i</code>键进入文件的编辑模式，在该文件中添加两行代码（将下边的代码粘贴进去)，指定 Git 的工作树（源代码）和 Git 目录（配置文件等）。</p><blockquote><p>#!/bin/bash<br><br>git –work-tree=/home/hexoBlog –git-dir=/home/git/hexoBlog.git checkout -f</p></blockquote><p>然后，按<code>Esc</code>键退出编辑模式，输入<code>:wq</code>保存退出。<br>修改文件权限，使得其可执行。</p><blockquote><p>chmod +x /home/git/hexoBlog.git/hooks/post-receive</p></blockquote><p>到这里，我们的 git 仓库算是完全搭建好了。下面进行 Nginx 的配置。</p><h1 id="3-云服务器端配置-Nginx"><a href="#3-云服务器端配置-Nginx" class="headerlink" title="3.云服务器端配置 Nginx"></a>3.云服务器端配置 Nginx</h1><p>安装 Nginx<br>yum install -y nginx<br>启动 Nginx<br>service nginx start<br>测试 Nginx 服务器<br>wget <a href="http://127.0.0.1" target="_blank" rel="noopener">http://127.0.0.1</a><br>能够正常获取以下欢迎页面说明Nginx安装成功。</p><pre><code>Connecting to 127.0.0.1:80... connected.HTTP request sent, awaiting response... 200 OKLength: 43704 (43K) [text/html]Saving to: ‘index.html’100%[=======================================&gt;] 43,704      --.-K/s   in 0s2018-03-09 23:04:09 (487 MB/s) - ‘index.html’ saved [43704/43704]</code></pre><ul><li><p>测试网页是否能打开<br>在浏览器中输入服务器 ip 地址，就是服务器的公网 ip。</p></li><li><p>配置 Nginx 托管文件目录</p><ul><li>接下来，创建 <code>/home/hexoBlog</code>目录，用于 <code>Nginx</code> 托管。<blockquote><p>mkdir /home/hexoBlog/<br><br>chown -R $USER:$USER /home/hexoBlog/<br><br>chmod -R 755 /home/hexoBlog/</p></blockquote></li></ul></li><li><p>查看 Nginx 的默认配置的安装位置</p></li></ul><blockquote><p>nginx -t</p></blockquote><ul><li>修改Nginx的默认配置，其中 cd 后边就是刚才查到的安装位置（每个人可能都不一样）</li></ul><blockquote><p>vim /etc/nginx/nginx.conf</p></blockquote><ul><li>按方向键，找到如下位置</li></ul><pre><code>server {    listen 80 default_server;    listen [::]:80 default_server;    root /home/hexoBlog;    #需要修改    server_name www.bujige.net; #需要修改    # Load configuration files for the default server block.    include /etc/nginx/default.d/*.conf;    location / {    }    error_page 404 /404.html;        location = /40x.html {    }</code></pre><p>按<code>i</code>键进入插入模式，将其中的 root 值改为<code>/home/hexoBlog</code> （刚才创建的托管仓库目录）。<br>将 server_name 值改成你的域名。</p><ul><li>重启 Nginx 服务</li></ul><blockquote><p>service nginx restart</p></blockquote><p>至此，服务器端配置就结束了。接下来，就剩下本地 hexo 的配置更改了。</p><h1 id="4-修改-hexo-站点配置文件-git-相关设置"><a href="#4-修改-hexo-站点配置文件-git-相关设置" class="headerlink" title="4. 修改 hexo 站点配置文件 git 相关设置"></a>4. 修改 hexo 站点配置文件 git 相关设置</h1><ul><li>打开你本地的 hexo 博客所在文件，打开站点配置文件（不是主题配置文件），做以下修改。</li></ul><blockquote><p>deploy:<br><br>    type: git<br><br>    repo: root@CVM 你的云服务器的IP地址:/home/git/hexoBlog<br><br>    branch: master</p></blockquote><ul><li>在 hexo 目录下执行部署，试试看。</li></ul><blockquote><p>cd 你的 hexo 目录<br><br>hexo clean<br><br>hexo generate<br><br>hexo deploy<br></p></blockquote><ul><li><p>打开你的公网 IP，看是不是已经部署成功了。<br><img src="https://note.youdao.com/yws/public/resource/4446b015d9dc2fb92d362fab8b947642/xmlnote/BD3DBBB4EC2E49ABA90A87DE1E9C7875/1416" alt></p></li><li><p>最后一步，更改域名解析。这一步不再做介绍。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>log4j的使用</title>
      <link href="/2018/06/11/log4j-de-shi-yong/"/>
      <url>/2018/06/11/log4j-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一个完整的软件，日志是必不可少的。程序从开发、测试、维护、运行等环节，都需要向控制台或文件等位置输出大量信息。这些信息的输出， 在很多时候是使用 <code>System.out.println()</code> 无法完成的。</p><p>日志信息根据用途与记录内容的不同，分为 <strong>调试日志、运行日志、异常日志</strong>等。</p><p><code>Log4j</code> 的全称为 <code>Log for java</code>，即专门用于 Java 语言的日志记录工具。</p><h1 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h1><p>为了方便对于日志信息的输出显示，对日志内容进行了分级管理。日志级别由高到低，共分 6 个级别：</p><ul><li>fatal(致命的)</li><li>error</li><li>warn</li><li>info</li><li>debug</li><li>trace(堆栈)<h1 id="为什么要对日志进行分级"><a href="#为什么要对日志进行分级" class="headerlink" title="为什么要对日志进行分级"></a>为什么要对日志进行分级</h1></li></ul><p>无论是将日志输出到控制台，还是文件，其输出都会降低程序的运行效率。但由于调试、运行维护的需要，客户的要求等原因，需要进行必要的日志输出。这时就必须要在代码中加入日志输出语句。</p><p>这些输出语句若在程序运行时全部执行， 则势必会降低运行效率。例如， 使用 System.out.println() 将信息输出到控制台，则所有的该输出语句均将执行。会大大降低程序的执行效率。而要使其不输出，唯一的办法就是将这些输出语句逐个全部删除。这是个费时费力的过程。</p><p>将日志信息进行分级管理，便可方便的控制信息输出内容及输出位置：哪些信息需要输出，哪些信息不需要输出，只需在一个日志输出控制文件中稍加修改即可。而代码中的输出语句不用做任何修改。</p><p>从这个角度来说，代码中的日志编写，其实就是写大量的输出语句。只不过，这些输出语句比较特殊，它们具有级别，在程序运行期间不一定被执行。它们的执行是由另一个控制文件控制。</p><h1 id="日志输出简介"><a href="#日志输出简介" class="headerlink" title="日志输出简介"></a>日志输出简介</h1><p>Log4j 的日志输出控制文件，主要由三个部分构成：</p><ul><li>日志信息的输出位置：控制日志信息将要输出的位置，是控制台还是文件等。</li><li>日志信息的输出格式：控制日志信息的显示格式，即以怎样的字符串形式显示。</li><li>日志信息的输出级别：控制日志信息的显示内容，即显示哪些级别的日志信息。<br>有了日志输出控制文件，代码中只要设置好日志信息内容及其级别即可，通过控制文件便可控制这些日志信息的输出了。</li></ul><h1 id="日志属性配置文件"><a href="#日志属性配置文件" class="headerlink" title="日志属性配置文件"></a>日志属性配置文件</h1><p>日志属性文件 <code>log4j.properties</code> 是专门用于控制日志输出的。其主要进行三方面控制：</p><p>输出位置：控制日志将要输出的位置，是控制台还是文件等。<br>输出布局：控制日志信息的显示形式。<br>输出级别：控制要输出的日志级别。<br>日志属性文件由两个对象组成：日志附加器与根日志。</p><p>根日志，即为 Java 代码中的日志记录器，其主要由两个属性构成：日志输出级别与日志附加器。</p><p>日志附加器，则由日志输出位置定义，由其它很多属性进行修饰，如输出布局、文件位置、文件大小等。</p><h1 id="什么是日志附加器？"><a href="#什么是日志附加器？" class="headerlink" title="什么是日志附加器？"></a>什么是日志附加器？</h1><p>所谓日志附加器，就是为日志记录器附加上很多其它设置信息。附加器的本质是一个接口，其定义语法为：<code>log4j.appender.appenderName</code> = <code>输出位置</code></p><h1 id="常用的附加器实现类"><a href="#常用的附加器实现类" class="headerlink" title="常用的附加器实现类"></a>常用的附加器实现类</h1><ul><li><p>org.apache.log4j.ConsoleAppender：日志输出到控制台</p></li><li><p>org.apache.log4j.FileAppender：日志输出到文件</p></li><li><p>org.apache.log4j.RollingFileAppender：当日志文件大小到达指定尺寸的时候将产生一个新的日志文件</p></li><li><p>org.apache.log4j.DailyRollingFileAppender：每天产生一个日志文件</p><h1 id="常用布局类型"><a href="#常用布局类型" class="headerlink" title="常用布局类型"></a>常用布局类型</h1></li><li><p>org.apache.log4j.HTMLLayout：网页布局，以 HTML 表格形式布局</p></li><li><p>org.apache.log4j.SimpleLayout：简单布局，包含日志信息的级别和信息字符串</p></li><li><p>org.apache.log4j.PatternLayout：匹配器布局，可以灵活地指定布局模式。其主要是通过设置 PatternLayout 的 ConversionPattern 属性值来控制具体输出格式的 。<br>打印参数: Log4J 采用类似 C 语言中的 printf 函数的打印格式格式化日志信息</p></li><li><p>%m：输出代码中指定的消息</p></li><li><p>%p：输出优先级，即 DEBUG，INFO，WARN，ERROR，FATAL</p></li><li><p>%r：输出自应用启动到输出该 log 信息耗费的毫秒数</p></li><li><p>%c：输出所属的类目，通常就是所在类的全名</p></li><li><p>%t：输出产生该日志事件的线程名</p></li><li><p>%n：输出一个回车换行符，Windows 平台为 /r/n，Unix 平台为 /n</p></li><li><p>%d：输出日志时间点的日期或时间，默认格式为 ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 22:10:28,921</p></li><li><p>%l：输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )</p></li></ul><h1 id="Slf4j-简介"><a href="#Slf4j-简介" class="headerlink" title="Slf4j 简介"></a>Slf4j 简介</h1><p>slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 <code>org.apache.log4j.Logger</code>，JDK 自带的 <code>java.util.logging.Logger</code> 以及 log4j 等。<br>(Slf4j只有实现，也就是一个接口)</p><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>继续之前的项目，pom.xml 配置如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.funtl&lt;/groupId&gt;    &lt;artifactId&gt;hello-spring&lt;/artifactId&gt;    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;            &lt;version&gt;1.7.25&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>主要增加了<code>org.slf4j:slf4j-log4j12</code> 依赖</p><h1 id="创建-log4j-properties配置文件"><a href="#创建-log4j-properties配置文件" class="headerlink" title="创建 log4j.properties配置文件"></a>创建 <code>log4j.properties</code>配置文件</h1><p>在 <code>src/main/resources</code> 目录下创建名为<code>log4j.properties</code> 的属性配置文件</p><pre><code>log4j.rootLogger=INFO, console, filelog4j.appender.console=org.apache.log4j.ConsoleAppenderlog4j.appender.console.layout=org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=%d %p [%c] - %m%nlog4j.appender.file=org.apache.log4j.DailyRollingFileAppenderlog4j.appender.file.File=logs/log.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.A3.MaxFileSize=1024KBlog4j.appender.A3.MaxBackupIndex=10log4j.appender.file.layout.ConversionPattern=%d %p [%c] - %m%n</code></pre><p>日志配置相关说明：</p><ul><li><code>log4j.rootLogger</code>：根日志，配置了日志级别为 INFO，预定义了名称为 console、file 两种附加器</li><li><code>log4j.appender.console</code>：console 附加器，日志输出位置在控制台</li><li><code>log4j.appender.console.layout</code>：console 附加器，采用匹配器布局模式</li><li><code>log4j.appender.console.layout.ConversionPattern</code>：console 附加器，日志输出格式为：日期 日志级别 [类名] - 消息换行符</li><li><code>log4j.appender.file</code>：file 附加器，每天产生一个日志文件</li><li><code>log4j.appender.file.File</code>：file 附加器，日志文件输出位置 logs/log.log</li><li><code>log4j.appender.file.layout</code>：file 附加器，采用匹配器布局模式</li><li><code>log4j.appender.A3.MaxFileSize</code>：日志文件最大值</li><li><code>log4j.appender.A3.MaxBackupIndex</code>：最多纪录文件数</li><li><code>log4j.appender.file.layout.ConversionPattern</code>：file 附加器，日志输出格式为：日期 日志级别 [类名] - 消息<code>换行符</code><h1 id="测试日志输出"><a href="#测试日志输出" class="headerlink" title="测试日志输出"></a>测试日志输出</h1>创建一个测试类，并测试日志输出效果，代码如下：<pre><code>package com.funtl.hello.spring;</code></pre></li></ul><p>import org.slf4j.Logger;<br>import org.slf4j.LoggerFactory;</p><p>public class MyTest {</p><pre><code>public static final Logger logger = LoggerFactory.getLogger(MyTest.class);public static void main(String[] args) {    logger.info(&quot;slf4j for info&quot;);    logger.debug(&quot;slf4j for debug&quot;);    logger.error(&quot;slf4j for error&quot;);    logger.warn(&quot;slf4j for warn&quot;);    String message = &quot;Hello SLF4J&quot;;    logger.info(&quot;slf4j message is : {}&quot;, message);}</code></pre><p>}</p><pre><code>此时控制台显示为：</code></pre><p>2018-06-07 05:15:42,914 INFO [com.funtl.hello.spring.MyTest] - slf4j for info<br>2018-06-07 05:15:42,915 ERROR [com.funtl.hello.spring.MyTest] - slf4j for error<br>2018-06-07 05:15:42,915 WARN [com.funtl.hello.spring.MyTest] - slf4j for warn<br>2018-06-07 05:15:42,916 INFO [com.funtl.hello.spring.MyTest] - slf4j message is : Hello SLF4J<br>```<br>项目根目录下也会多出 <code>logs/log.log</code> 目录及文件</p><h1 id="附：占位符说明"><a href="#附：占位符说明" class="headerlink" title="附：占位符说明"></a>附：占位符说明</h1><p>打日志的时候使用了<code>{}</code> 占位符，这样就不会有字符串拼接操作，减少了无用 <code>String</code> 对象的数量，节省了内存。并且，记住，在生产最终日志信息的字符串之前，这个方法会检查一个特定的日志级别是不是打开了，这不仅降低了内存消耗而且预先降低了<code>CPU</code> 去处理字符串连接命令的时间。</p>]]></content>
      
      
      <categories>
          
          <category> log4j </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> log4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高内聚低耦合</title>
      <link href="/2018/06/01/gao-nei-ju-di-ou-he/"/>
      <url>/2018/06/01/gao-nei-ju-di-ou-he/</url>
      
        <content type="html"><![CDATA[<p>随笔：<br>视图层<br>业务逻辑层 service<br>数据访问层 Dao 数据访问对象（持久层）</p><p>在开发中，业务才是核心</p><p>新的技术诞生都是为了提高产品的</p><ul><li>效率</li><li>安全性</li><li>易于维护，使用</li></ul><blockquote><p>总结：技术是辅助业务的</p></blockquote><p>业务问题</p><p>业务是有复杂度的，事务</p><p>又分为：</p><ul><li>简单业务  开启一个事务</li><li>普通业务  开启三个事务</li><li>复杂业务  开启七个事务</li></ul><p>多张表之间有依赖关系   –&gt; 强关联性</p><p>所有业务都写进main方法那么这个就是      <code>高耦合</code></p><p>方法技巧：</p><ul><li>一个类只做一件事</li><li>一个方法只做一件事</li><li>写且只写一次<ul><li>例如：工具类–&gt;日期管理–&gt;依赖专门负责日期运算方法</li><li>例如：数学工具类<br>日期也有加减  四则运算<br>（当日期类依赖了数学类就是强相关的，耦合就产生了）<blockquote><p>按照以上三个步骤就可以实现<code>高内聚，低耦合</code></p></blockquote></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是MVC模式</title>
      <link href="/2018/05/16/shi-me-shi-mvc-mo-shi/"/>
      <url>/2018/05/16/shi-me-shi-mvc-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>MVC，即 Model 模型、View 视图，及 Controller 控制器。</p><ul><li>View：视图，为用户提供使用界面，与用户直接进行交互。</li><li>Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载 Bean，一类称为业务处理 Bean。所谓数据承载 Bean 是指实体类，专门用户承载业务数据的，如 Student、User 等。而业务处理 Bean 则是指 Service 或 Dao 对象， 专门用于处理用户提交请求的。</li><li>Controller：控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。<h1 id="MVC-架构程序的工作流程"><a href="#MVC-架构程序的工作流程" class="headerlink" title="MVC 架构程序的工作流程"></a>MVC 架构程序的工作流程</h1></li><li>用户通过 View 页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等</li><li>服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理</li><li>Model 处理后，将处理结果再交给 Controller</li><li>Controller 在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端。</li></ul><p><img src="https://funtl.com/assets/Lusifer2018060421090002.png" alt></p><h1 id="三层架构-MVC-示意图"><a href="#三层架构-MVC-示意图" class="headerlink" title="三层架构 + MVC 示意图"></a>三层架构 + MVC 示意图</h1><p><img src="https://funtl.com/assets/Lusifer2018060421090003.png" alt></p><p>PS : <code>MVC模式</code>是三层架构的<code>视图层</code></p><p>说说你对设计原则的理解</p><p>口诀</p><p>为了便于记忆,我们可以使用一一个几决来记忆面向对象设计原则:开口合里最单依</p><p>开:开闭原则<br>口:接口隔离原则<br>合:组合/聚合原则<br>里:里式替换原则<br>最:最少知识原则(迪米特法则)<br>单:单一职责原则<br>依:依赖倒置原则<br>开闭原则(Open-Closed Principle, 0CP)</p><p>一个软件实体应当刘扩展开发，对修改关闭说的是，再设计一个模块的时候,应当使这个模块可以在不被修改的前提下被扩展换言之，应当可以在不必修改源代码的情况下改变这个模块的行为,在保持系统定稳定性的基础F ,对系统进行扩展。这是面向对象设计( 0OD )的基石，也是最重要的原则。</p><p>接口隔离原则(Interface Segregation Principle, ISP)</p><p>一个类对另外一个类的依赖是建立在最小的接山上。</p><p>使用多个专J的接口比使用单-的总接C要好根据客户需要的不同，而为不同的客户端提供不同的服务是一 种应当得到鼓励的做法。就像”看人下菜碟”一 -样要看客人是谁，再提供不同档次的饭菜.</p><p>胖接口会导致他们的客户程序之间产生不正常的并且有害的耦合关系当一个客户程序要求该胖接口进行-一个改动时,会影响到所有其他的客户程序,因此客户程序应该仅仅依赖他们实际需要调用的方法.</p><p>组合/聚合复用原则(Composite/Aggregate Reuse Principle , CARP)</p><p>在一个新的对象里面使用一些已有的对象,使之成为新对象的一部分;新的对象通过这些向对象的委派达到复用已有功能的目的.这个设计原则有另一个简短的表述:要尽量使用合成/聚合,尽量不要使用继承.</p><p>里氏代换原则(Liskov Substitution Principle，LSP)</p><h1 id="说说你对设计原则的理解"><a href="#说说你对设计原则的理解" class="headerlink" title="说说你对设计原则的理解"></a>说说你对设计原则的理解</h1><h3 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h3><p>为了便于记忆,我们可以使用一一个几决来记忆面向对象设计原则:开口合里最单依</p><ul><li>开:开闭原则</li><li>口:接口隔离原则</li><li>合:组合/聚合原则</li><li>里:里式替换原则</li><li>最:最少知识原则(迪米特法则)</li><li>单:单一职责原则</li><li>依:依赖倒置原则</li></ul><h3 id="开闭原则-Open-Closed-Principle-0CP"><a href="#开闭原则-Open-Closed-Principle-0CP" class="headerlink" title="开闭原则(Open-Closed Principle, 0CP)"></a>开闭原则(Open-Closed Principle, 0CP)</h3><p>一个软件实体应当刘扩展开发，对修改关闭说的是，再设计一个模块的时候,应当使这个模块可以在不被修改的前提下被扩展换言之，应当可以在不必修改源代码的情况下改变这个模块的行为,在保持系统定稳定性的基础F ,对系统进行扩展。这是面向对象设计( 0OD )的基石，也是最重要的原则。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h3><ul><li><p>一个类对另外一个类的依赖是建立在最小的接山上。</p></li><li><p>使用多个专J的接口比使用单-的总接C要好根据客户需要的不同，而为不同的客户端提供不同的服务是一 种应当得到鼓励的做法。就像”看人下菜碟”一 -样要看客人是谁，再提供不同档次的饭菜.</p></li><li><p>胖接口会导致他们的客户程序之间产生不正常的并且有害的耦合关系当一个客户程序要求该胖接口进行-一个改动时,会影响到所有其他的客户程序,因此客户程序应该仅仅依赖他们实际需要调用的方法.</p></li></ul><h3 id="组合-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP"><a href="#组合-聚合复用原则-Composite-Aggregate-Reuse-Principle-CARP" class="headerlink" title="组合/聚合复用原则(Composite/Aggregate Reuse Principle , CARP)"></a>组合/聚合复用原则(Composite/Aggregate Reuse Principle , CARP)</h3><p>在一个新的对象里面使用一些已有的对象,使之成为新对象的一部分;新的对象通过这些向对象的委派达到复用已有功能的目的.这个设计原则有另一个简短的表述:要尽量使用合成/聚合,尽量不要使用继承.</p><h3 id="里氏代换原则-Liskov-Substitution-Principle，LSP"><a href="#里氏代换原则-Liskov-Substitution-Principle，LSP" class="headerlink" title="里氏代换原则(Liskov Substitution Principle，LSP)"></a>里氏代换原则(Liskov Substitution Principle，LSP)</h3><p>由 Barbar Liskov (芭芭拉.里氏) 提出，是继承复用的基石。</p><p>所有引用基类的地方必须透明的使用其子类的对象。只要父类能出现的地方子类也可以出现，而且替换为子类不会产生任何错误或异常，但是反过来就不行，有子类出现的地方，父类未必就能适应。</p><h3 id="最少知识原则-Least-Knowledge-Principle，LKP"><a href="#最少知识原则-Least-Knowledge-Principle，LKP" class="headerlink" title="最少知识原则(Least Knowledge Principle，LKP)"></a>最少知识原则(Least Knowledge Principle，LKP)</h3><p>一个对象应当对其他对象有尽可能少的了解.</p><p>没有任何一个其他的 OO 设计原则象迪米特法则这样有如此之多的表述方式,如下几种：</p><ul><li>只与你直接的朋友们通信(Only talk to your immediate friends)</li><li>不要跟”陌生人”说话(Don’t talk to strangers)</li><li>每一个软件单位对其他的单位都只有最少的知识,而且局限于那些本单位密切相关的软件单位</li></ul><p>就是说,如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用,如果其中的一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用。</p><h3 id="单一职责原则-Simple-responsibility-pinciple，SRP"><a href="#单一职责原则-Simple-responsibility-pinciple，SRP" class="headerlink" title="单一职责原则(Simple responsibility pinciple，SRP)"></a>单一职责原则(Simple responsibility pinciple，SRP)</h3><p>就一个类而言,应该仅有一个引起它变化的原因,如果你能想到多于一个的动机去改变一个类,那么这个类就具有多于一个的职责.应该把多于的指责分离出去,分别再创建一些类来完成每一个职责.</p><h3 id="依赖倒置原则-Dependence-Inversion-Principle"><a href="#依赖倒置原则-Dependence-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle)"></a>依赖倒置原则(Dependence Inversion Principle)</h3><p>要求客户端依赖于抽象耦合.</p><ul><li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过- 接口或抽象类产生的。</li><li>接口或抽象类不依赖实现类</li><li>实现类依赖接口或抽象类</li></ul><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定，降低并行开发引起的风险，提高代码的可读性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> MVC模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> MVC模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是三层架构</title>
      <link href="/2018/05/11/shi-me-shi-san-ceng-jia-gou/"/>
      <url>/2018/05/11/shi-me-shi-san-ceng-jia-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是系统架构"><a href="#什么是系统架构" class="headerlink" title="什么是系统架构"></a>什么是系统架构</h1><p>所谓系统架构是指，整合应用系统程序大的结构。经常提到的系统结构有两种：三层架构与 MVC。这两种结构既有区别，又有联系。但这两种结构的使用，均是为了降低系统模块间的耦合度。</p><h1 id="什么是三层架构"><a href="#什么是三层架构" class="headerlink" title="什么是三层架构"></a>什么是三层架构</h1><p>三层架构是指：视图层 View、服务层 Service，与持久层 DAO。它们分别完成不同的功能。</p><ul><li>View 层：用于接收用户提交请求的代码</li><li>Service 层：系统的业务逻辑主要在这里完成</li><li>DAO 层：直接操作数据库的代码<br>为了更好的降低各层间的耦合度，在三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间解耦合。</li></ul><p><img src="https://funtl.com/assets/Lusifer2018060421090001.png" alt></p><h1 id="为什么需要架构"><a href="#为什么需要架构" class="headerlink" title="为什么需要架构"></a>为什么需要架构</h1><p>随着系统的升级，业务结构就越来复杂，越复杂的系统它的耦合度就越高，所以就需要架构进行解耦合。<br><img src="https://funtl.com/assets/Lusifer2018060421090001.png" alt></p><h1 id="随笔："><a href="#随笔：" class="headerlink" title="随笔："></a>随笔：</h1><p>视图层</p><p>业务逻辑层 service</p><p>数据访问层 Dao 数据访问对象（持久层）</p><h1 id="在开发中，业务才是核心"><a href="#在开发中，业务才是核心" class="headerlink" title="在开发中，业务才是核心"></a>在开发中，业务才是核心</h1><p>新的技术诞生都是为了提高产品的</p><ul><li>效率</li><li>安全性</li><li>易于维护，使用</li></ul><blockquote><p>总结：技术是辅助业务的</p></blockquote><p><strong>业务问题</strong></p><p>业务是有复杂度的，事务</p><p>又分为：</p><ul><li>简单业务  开启一个事务</li><li>普通业务  开启三个事务</li><li>复杂业务  开启七个事务</li></ul><p>多张表之间有依赖关系   –&gt; 强关联性</p><p>所有业务都写进main方法那么这个就是      <code>高耦合</code></p><p>方法技巧：</p><ul><li>一个类只做一件事</li><li>一个方法只做一件事</li><li>写且只写一次<ul><li>例如：工具类–&gt;日期管理–&gt;依赖专门负责日期运算方法</li><li>例如：数学工具类<br>日期也有加减  四则运算<br>（当日期类依赖了数学类就是强相关的，耦合就产生了）<blockquote><p>按照以上三个步骤就可以实现<code>高内聚，低耦合</code></p></blockquote></li></ul></li></ul><h1 id="Model-角色"><a href="#Model-角色" class="headerlink" title="Model              角色"></a>Model              角色</h1><p>数据模型  Entity     JSP</p><p>业务模型  Service   </p><p>控制器 Controller  处理用户的请求</p><p>Servlet 服务器的小程序</p><ul><li>处理业务逻辑</li><li>处理页面展示</li></ul><p>JSP就是Servlet 处理页面展示的技术  .asp  .jsp  .php</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架</title>
      <link href="/2018/05/05/spring-kuang-jia/"/>
      <url>/2018/05/05/spring-kuang-jia/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Spring 的主要作用就是为代码“解耦”，降低代码间的耦合度。</p><p>根据功能的不同，可以将一个系统中的代码分为 <strong>主业务逻辑</strong> 与 <strong>系统级业务逻辑</strong> 两类。它们各自具有鲜明的特点：主业务代码间逻辑联系紧密，有具体的专业业务应用场景，复用性相对较低；系统级业务相对功能独立，没有具体的专业业务应用场景，主要是为主业务提供系统级服务，如日志、安全、事务等，复用性强。</p><p>Spring 根据代码的功能特点，将降低耦合度的方式分为了两类：IoC 与 AOP。IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”。而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。</p><p>Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 的核心是控制反转（IoC）和面向切面编程（AOP）。简单来说，Spring 是一个分层的 Java SE/EE full-stack(一站式)轻量级开源框架。</p><h1 id="Spring-体系结构"><a href="#Spring-体系结构" class="headerlink" title="Spring 体系结构"></a>Spring 体系结构</h1><p><img src="https://funtl.com/assets/spring-overview.png" alt></p><p>Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、Web、面向切面编程（AOP, Aspects）、应用服务器设备管理（Instrumentation）、消息发送（Messaging）、核心容器（Core Container）和测试（Test）。</p><h1 id="Spring-的特点"><a href="#Spring-的特点" class="headerlink" title="Spring 的特点"></a>Spring 的特点</h1><h3 id="非侵入式"><a href="#非侵入式" class="headerlink" title="非侵入式"></a>非侵入式</h3><p>所谓非侵入式是指，Spring 框架的 API 不会在业务逻辑上出现，即业务逻辑是 POJO。由于业务逻辑中没有 Spring 的 API，所以业务逻辑可以从 Spring 框架快速的移植到其他框架， 即与环境无关。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Spring 作为一个容器，可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过配置文件，来定义对象，以及设置与其他对象的依赖关系。</p><h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h3><p>控制反转（Inversion of Control），即创建被调用者的实例不是由调用者完成，而是由 Spring 容器完成，并注入调用者。</p><p>当应用了 IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。即，不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。</p><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>面向切面编程（AOP，Aspect Orient Programming），是一种编程思想，是面向对象编程 OOP 的补充。很多框架都实现了对 AOP 编程思想的实现。Spring 也提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如日志和事务管理）进行开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。</p><p>我们可以把日志、安全、事务管理等服务理解成一个“切面”，那么以前这些服务一直是直接写在业务逻辑的代码当中的，这有两点不好：首先业务逻辑不纯净；其次这些服务被很多业务逻辑反复使用，完全可以剥离出来做到复用。那么 AOP 就是这些问题的解决方案， 可以把这些服务剥离出来形成一个“切面”，以期复用，然后将“切面”动态的“织入”到业务逻辑中，让业务逻辑能够享受到此“切面”的服务。</p><h1 id="Spring-与-IoC"><a href="#Spring-与-IoC" class="headerlink" title="Spring 与 IoC"></a>Spring 与 IoC</h1><p>控制反转（IoC，Inversion of Control），是一个概念，是一种思想。指将传统上由程序代码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对象控制权的转移，从程序代码本身反转到了外部容器。</p><p>IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式有两种： 依赖注入和依赖查找。依赖注入方式应用更为广泛。</p><ul><li>依赖查找：Dependency Lookup，DL，容器提供回调接口和上下文环境给组件，程序代码则需要提供具体的查找方式。比较典型的是依赖于 JNDI 系统的查找。</li><li><strong>依赖注入：</strong>Dependency Injection，DI，程序代码不做定位查询，这些工作由容器自行完成。<br>依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序。</li></ul><p>Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持 POJO 之间依赖关系的管理。</p><p><strong>依赖注入是目前最优秀的解耦方式</strong>。依赖注入让 Spring 的 Bean 之间以配置文件的方式组织在一起，而不是以硬编码的方式耦合在一起的。</p><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p>创建一个工程名为 hello-spring 的项目，pom.xml 文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.lele&lt;/groupId&gt;    &lt;artifactId&gt;hello-spring&lt;/artifactId&gt;    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>主要增加了 org.springframework:spring-context 依赖</p><h1 id="创建接口与实现"><a href="#创建接口与实现" class="headerlink" title="创建接口与实现"></a>创建接口与实现</h1><h3 id="创建-UserService-接口"><a href="#创建-UserService-接口" class="headerlink" title="创建 UserService 接口"></a>创建 <code>UserService</code> 接口</h3><pre><code>package com.lele.hello.spring.service;public interface UserService {    public void sayHi();}</code></pre><h3 id="创建-UserServiceImpl-实现"><a href="#创建-UserServiceImpl-实现" class="headerlink" title="创建 UserServiceImpl 实现"></a>创建 UserServiceImpl 实现</h3><pre><code>package com.lele.hello.spring.service.impl;import com.lele.hello.spring.service.UserService;public class UserServiceImpl implements UserService {    public void sayHi() {        System.out.println(&quot;Hello Spring&quot;);    }}</code></pre><h1 id="创建-Spring-配置文件"><a href="#创建-Spring-配置文件" class="headerlink" title="创建 Spring 配置文件"></a>创建 Spring 配置文件</h1><p>在 <code>src/main/resources</code> 目录下创建 <code>spring-context.xml</code> 配置文件，从现在开始类的实例化工作交给 Spring 容器管理（IoC），配置文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.lele.hello.spring.service.impl.UserServiceImpl&quot; /&gt;&lt;/beans&gt;</code></pre><ul><li><p><bean>：用于定义一个实例对象。一个实例对应一个 bean 元素。</bean></p></li><li><p>id：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean，Bean 与 Bean 间的依赖关系也是通过 id 属性关联的。</p></li><li><p>class：指定该 Bean 所属的类，注意这里只能是类，不能是接口。</p></li></ul><h1 id="测试-Spring-IoC"><a href="#测试-Spring-IoC" class="headerlink" title="测试 Spring IoC"></a>测试 Spring IoC</h1><p>创建一个 MyTest 测试类，测试对象是否能够通过 Spring 来创建，代码如下：</p><pre><code>package com.lele.hello.spring;import com.lele.hello.spring.service.UserService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest {    public static void main(String[] args) {        // 获取 Spring 容器        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;);        // 从 Spring 容器中获取对象        UserService userService = (UserService) applicationContext.getBean(&quot;userService&quot;);        userService.sayHi();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于intelij IDEA2019.2的使用教程</title>
      <link href="/2018/05/02/guan-yu-intelij-idea2019-2-de-shi-yong-jiao-cheng/"/>
      <url>/2018/05/02/guan-yu-intelij-idea2019-2-de-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>工欲善其事<br>必先利其器</p></blockquote><p>同时，在这次分享之后，本人自己也学习到了一些新的使用技巧，所以借着这次机会，一起分享出来。希望可以帮到一些人，不能浪费IDEA这个优秀的IDE呀。</p><blockquote><p>基于的 IDEA 版本信息：IntelliJ IDEA 2019.2版本</p></blockquote><h2 id="知识点概览："><a href="#知识点概览：" class="headerlink" title="知识点概览："></a>知识点概览：</h2><ul><li><p>高效率配置</p></li><li><p>日常使用 必备快捷键（★★）</p></li></ul><pre><code>- 查找- 跳转切换- 编码相关- 代码阅读相关- 版本管理相关</code></pre><ul><li><p>编码效率相关（★★）</p><ul><li><p>文件代码模板</p></li><li><p>实时代码模板</p></li><li><p>其他</p></li></ul></li><li><p>代码调试 源码阅读相关（★★★）</p><ul><li><p>视图模式</p></li><li><p>代码调试</p></li><li><p>…</p></li></ul></li><li><p>插件方面</p><ul><li><p>插件的安装与使用</p></li><li><p>插件推荐</p></li></ul></li><li><p>参考</p><hr><h2 id="标题高效率配置"><a href="#标题高效率配置" class="headerlink" title="标题高效率配置"></a>标题高效率配置</h2><ol><li>代码提示不区分大小写</li></ol><p>Settings -&gt; Editor -&gt; General -&gt; Code Completion<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNPaWJub0V0dVNpYVVhRjdjblRyanFjbWlhZHBEdHJwcXEwYlV1SHNvMUx5WlZJbElCMUwyeEJwckEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>(低版本 将 Case sensitive completion 设置为 None 就可以了)</p></li></ul><ol start="2"><li>自动导包功能及相关优化功能</li></ol><p>Settings -&gt; Editor -&gt; General -&gt; Auto Import<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNuYmg2bjVSOTF2eUI3a05XZkZyd2tQNDJhQm1GcFdvRWQ1dnp2OGlia1I0WHZDbTFOQ1lUNUhnLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><ol start="3"><li>CTRL + 滑动滚轮 调整窗口显示大小</li></ol><p>Settings -&gt; Editor -&gt; General -&gt; Change font size (Zoom) with Ctrl+Mouse wheel</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNMNWJRVkZtRzl0RG9vU3hSY3ppYnpveU5PZWtNTHhWTFg3RHFYRGYzeXR2SlVsWGZMaWFuaWJOeEEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>选择之后，就可以通过CTRL+滑动滚轮的方式，调整编辑器窗口的字体大小</p><p>4.tab 多行显示</p><p>这点因人而异，有些人喜欢直接取消所有tab，改用快捷键的方式，我屏幕比较大，所以喜欢把tab全部显示出来。</p><p>Window -&gt; Editor Tabs -&gt; Tabs Placement，取消勾选 Show Tabs In Single Row选项。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnN3VWNBemxpY016NGVpY2s1YW9ZUGtjcVRWcWVqbjQzZDM0NmpraWI3UkZ3VXBINlYySzcxRGdGQWcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>效果如下：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkMzZqQUNMWGd0ODdoc0Zzd2liOURFaWNqanlJODFlOFRzYkF0djVpY3B4aWJkdEF0MlJyN0ZOTlhpYVFBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><ol start="5"><li>代码编辑区显示行号<br>Settings -&gt; Editor -&gt; General -&gt; Appearance 勾选 Show Line Numbers</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnM5cmJ1NUpIREtVM1RJcjZmWFVFVEw0aWNUR0NpYzBOZW9zRFRubVlPakpxdld4N1FpYkt1Nm5PSkEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNob2FRSGJWcnlHTmdSS2Z3VW9BejZWaWJ0S0dxSlBZUmoxVE1tTTdMa3VPRTFUMTg1bEw4a0R3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><hr><h2 id="日常使用-必备快捷键（★★）"><a href="#日常使用-必备快捷键（★★）" class="headerlink" title="日常使用 必备快捷键（★★）"></a>日常使用 必备快捷键（★★）</h2><p>查找<br>| 快捷键                       | 介绍                |<br>|—————————|——————-|<br>| Ctrl + F                 | 在当前文件进行文本查找       |<br>| Ctrl + R                 | 在当前文件进行文本替换       |<br>| Shift + Ctrl + F        | 在项目进行文本查找         |<br>| Shift + Ctrl + R        | 在项目进行文本替换         |<br>| Shift  + Shift           | 快速搜索              |<br>| Ctrl + N                 | 查找class           |<br>| Ctrl + Shift + N        | 查找文件              |<br>| Ctrl + Shift + Alt + N | 查找symbol（查找某个方法名） |</p><p>跳转切换</p><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + E</td><td>最近文件</td></tr><tr><td>Ctrl + Tab</td><td>切换文件</td></tr><tr><td>Ctrl  + Alt + ←/→</td><td>跳转历史光标所在处</td></tr><tr><td>Alt + ←/→ 方向键</td><td>切换子tab</td></tr><tr><td>Ctrl + G</td><td>go to（跳转指定行号）</td></tr></tbody></table><p>编码相关<br>| 快捷键                           | 介绍                                                |<br>|——————————-|—————————————————|<br>| Ctrl + W                     | 快速选中                                              |<br>| (Shift + Ctrl) + Alt + J | 快速选中同文本                                           |<br>| Ctrl + C/Ctrl + X/Ctrl + D | 快速复制或剪切                                           |<br>| 多行选中 Tab / Shift  + Tab      | tab                                               |<br>| Ctrl + Y                     | 删除整行                                              |<br>| 滚轮点击变量/方法/类                   | 快速进入变量/方法/类的定义处                                   |<br>| Shift + 点击Tab                | 快速关闭tab                                           |<br>| Ctrl + Z 、Ctrl + Shift + Z | 后悔药，撤销/取消撤销                                       |<br>| Ctrl + Shift + enter        | 自动收尾，代码自动补全                                       |<br>| Alt + enter                  | IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 |<br>| Alt + ↑/↓                    | 方法快速跳转                                            |<br>| F2                            | 跳转到下一个高亮错误 或 警告位置                                 |<br>| Alt + Insert                 | 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等    |<br>| Ctrl + Shift + L            | 格式化代码                                             |<br>| Shift + F6                   | 快速修改方法名、变量名、文件名、类名等                               |<br>| Ctrl + F6                    | 快速修改方法签名                                          |</p><p>代码阅读相关</p><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Shift + i</td><td>就可以在当前类里再弹出一个窗口出来</td></tr><tr><td>Alt + F7</td><td>可以列出变量在哪些地方被使用了</td></tr><tr><td>光标在子类接口名，Ctrl + u</td><td>跳到父类接口</td></tr><tr><td>Alt + F1 + 1， esc</td><td></td></tr><tr><td>(Shift) + Ctrl + +/-</td><td>代码块折叠</td></tr><tr><td>Ctrl + Shift + ←/→</td><td>移动窗口分割线</td></tr><tr><td>Ctrl  + (Alt) + B</td><td>跳转方法定义/实现</td></tr><tr><td>Ctrl  + H</td><td>类的层级关系</td></tr><tr><td>Ctrl  + F12</td><td>Show Members 类成员快速显示</td></tr></tbody></table><p>版本管理相关</p><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + D</td><td>Show Diff</td></tr><tr><td>(Shift) + F7</td><td>（上）下一处修改</td></tr></tbody></table><p>更多快捷键请参考此文章</p><blockquote><p>leblog.github.io</p></blockquote><hr><h2 id="编码效率相关（★★）"><a href="#编码效率相关（★★）" class="headerlink" title="编码效率相关（★★）"></a>编码效率相关（★★）</h2><p>文件代码模板</p><p>Settings -&gt; Editor -&gt; File and Code Template<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNhY0d6aWNrcklOOHhmZ05UaE15cU5mOUVLQzNGdk5VbzIzRUxWU2VHUTR4M3V2aHVIVW41bmV3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>在这里可以看到IDEA所有内置的文件代码模板，当你选择某个文件生成时，就会按照这里面的模板生成指定的代码文件。</p><p>另外，你可以在这里设置文件头。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnM3SWg1RGw2aWI0eVY1QmdGb0RQVk5BU0ZMRXNaYmhpYlRUQjRhdnJ0VGliTjNvZmN1TExobk9FVUEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>设置之后，效果如下</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM0docDZyUGtONzBueGc5bGtwVlBKNG5jVjNjREZ1TjBpYU14WTF3aWN4UEUwTksxVzJsMVpkTUJ3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>实时代码模板</p><p>IDEA提供了强大的实时代码模板功能，并且原生内置了很多的模板，比如，当你输入sout或者psvm，就会快速自动生成System.out.println();和public static void main(String[] args) {}的代码块。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnM4QjFZaklFdnZNZ2VtNlVQNnRkY2x2d1BXcGlhaWJDY2pFWEx1dDZGNTRzMUpFWXR1dndxTXBuQS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM2lhUEtCY2JSQnE4VHdYRDlmZ3pLUm5PU3p6VFZUUlFEbXdXa3IxdlRqRHBDeFdneHNzSWdpYll3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>这些的模板可以在Settings -&gt; Editor -&gt; Live Templates看到。使用者可以按照自己的使用习惯来熟悉相关的代码模板。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNoa2xEOXhKRTdDbzYzamZHMm10R2ZLS2ZaaWJreGliUWNaQXhad2dpYXY2V08wWlJXU0NsRWRBcWcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>定制代码模板</p><p>IDEA也提供自己定制实时代码模板的功能。</p><ul><li><p>创建自己的模板库</p></li><li><p>创建定制的代码模板<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM0R6aWJMNmY2YUdERGliaWN6YnQ4ZzBIdjRoT1RweGRBZUVhbjFKRDU4RUNSTVBYYUN0bVZVa3ZPUS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>图中的MyGroup就存放着我自己定义的代码模板。</p></li></ul><p>其他</p><p>CRTL+ALT+T<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNsRmxNZ2NHMjJ3S0Y2SnkxZUVCNVNKeWFXajFERUN3SEVhYUkydVYxV01STmJiZDVCejZNbEEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p>Ctrl + Alt + T 提供的是代码块包裹功能 - Surround With。可以快速将选中的代码块，包裹到选择的语句块中。</p><p>本地历史版本</p><p>IDEA 自带本地版本管理的功能，能够让你本地编写代码变得更加的安心和方便。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNBV2pYSk1RMURPNmROcUUwSmliTkwxSVlWVWlhbm1nNElXS2g0S2lhaGVPVU1idWxpYkN1T0NEaWFYdy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><hr></p><h2 id="代码调试-源码阅读相关（★★★）"><a href="#代码调试-源码阅读相关（★★★）" class="headerlink" title="代码调试 源码阅读相关（★★★）"></a>代码调试 源码阅读相关（★★★）</h2><p>视图模式<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNQUUJLdTVMU3hVQzJOcXF4OVVjRURGdUtaUWliOXZOZWtJVmlhVVpRQ2libExlM2RXb01FR0Q1N3cvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>IDEA提供两种特殊的视图模式，</p><ul><li><p>Presentation Mode - 演示模式，专门用于Code Review这种需要展示代码的场景</p></li><li><p>Distraction Free Mode - 禅模式，专注于代码开发</p></li></ul><p>代码调试</p><p><strong>1. 条件断点</strong></p><p>IDEA 可以设置指定条件的断点，增加我们调试的效率。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNpYkZHdGFpYm43RlpJMEl3OGxibHZMRGVpYjhLNUZGN0F2dmRwOWdBVU10bWhvRDkxaWEyZ2c4VzlBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>2. 强制返回</strong></p><p>IDEA 可以在打断点的方法栈处，强制返回你想要的方法返回值给调用方。非常灵活！<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNoVUhGQ1piVGljNmZpYnYwR0tCMkJOWXNlSlRXZzJIVGJtM3NnVUhxdFltdEpyYlFqRjFsaWJCTVEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnMxZ3FCWGVzR2lhUkxsTzJnZ0V1V0NaUk1YTGlhSURxVEhRUDcxUFBxYTk4TkhjZnRBRThSN3hyZy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>3. 模拟异常</strong></p><p>IDEA 可以在打断点的方法栈处，强制抛出异常给调用方。这个在调试源码的时候非常有用。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnN3VHYyS0hvRnNMd3JvajlwUlNwYzhnUUttYm9mSWo1YjUzMHVGTHM0RlBWR0Q4bzg4RFBpYXlnLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>4. Evaluate Expression</strong></p><p>IDEA 还可以在调试代码的时候，动态修改当前方法栈中变量的值，方便我们的调试。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNCeVQ3QXhTaWJNWTVDbTZmeG5xR1RKMWliVDRoY1NLREpReDFHRkM1SjY1U1REZUlGMFJMRmNkQS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><hr><h3 id="插件方面"><a href="#插件方面" class="headerlink" title="插件方面"></a>插件方面</h3><p><strong>插件安装</strong></p><p>File -&gt; Setting -&gt; Plugin</p><p>插件安装，可以直接在IDEA的插件库中实时搜索安装。browse plugin repository</p><p>对于网络不好的用户，可以登录官方插件仓库地址：plugins.jetbrains.com/idea，下载压缩包之后，选择<code>install from disk</code></p><p><strong>插件推荐</strong></p><p>本人日常开发中使用的插件</p><p><strong>Alibaba Java Coding Guidelines</strong></p><p>阿里Java编程规约插件</p><p><strong>FindBugs</strong></p><p>代码缺陷扫描<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM1E5cWZVOVM4SE1SQ2tTM2liMjZtZ0x5OHl2cm9OY0NKaWNOcjRlcHBYMXprcXJaMW5IQ25zRVZRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNrOXNJYmRDaGRpY0NZdWhydVlZWWljRTc1SXBpY2NVcVFWR3dWdjdsQWdVaWNxbUNINURadDVIMTFBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>PMD</strong></p><p>代码缺陷扫描</p><p><strong>InnerBuilder</strong></p><p>builder模式快速生成<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNWSG9uT2FGRERtOG5XcXlTT2V1OUFQWklZODFTVzJkRVFUT2liVjlldWJmWGdKZVlDdXQ1SUh3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>lombok plugin</strong></p><p>lombok 插件</p><p><strong>maven helper</strong></p><p>maven 依赖管理助手 ，解析maven pom结构，分析冲突；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNnaEQ2aWFvaWJoaWJpYklyWERQenBXMTROS2lhNmlheWdpYmdIbXhobkc3aWF4TDVXdnZxakl0WlUzeDI2QS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnMxWUZrYlE5YWlieENoa3NSTU5vbktibU9LNnRGcE83S2VXalM3bTB4TUdNSlZjM3hhQ3YwcGtBLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><p><strong>Rainbow brackets</strong></p><p>让代码中的括号更具标识性<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNyTkNKOTVNeFJPZVFXMFhaNVR3dk5HMDJ1MVVVaWJDZGJrdEJYQWZ5V3QzU2ljOFZ1aWNncWpOOUEvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>String Manipulation</strong></p><p>String相关辅助简化，搭配 CTRL+W 、ALT+J等文本选择快捷键使用<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9lUVB5QmZmWWJ1ZmVEUGY4MzkydkFqdHp6MzNMWGVjd2xMZ005dmNFZ1NNU2M1QTZLRGQxVTZ3VzlYMHlRUzFYNDdQMnlDR0hQa1Y4Rm4zbUhMQjRvZy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>Translation</strong></p><p>翻译插件，阅读源码必备<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnM2RlhueEtRM04wYlgxekVvak1DNENxU1NISHU0QnBvM2pJaHVaOWZJNXBpYjRXN3psNmpBU1NRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNxTVViZjNiZ1o2ZWliaWJZdkdBOTlkQUZPYUlZR2t3TkR0MEFVZm1NRVV6akVyMnVMWW5hSVNrZy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>GenerateAllSetter</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNLSHJtSGJDVUtrcThjT1JhYmljSXY5RE9vSnpqWGZoTmliMUVubDlOVWlhdXpFV2gxYVFmUjd2T3cvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"></p><pre><code>**Key Promoter X**</code></pre><p>对你的鼠标操作进行 快捷键提示<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9lUVB5QmZmWWJ1ZmVEUGY4MzkydkFqdHp6MzNMWGVjd0FFSUhSTUw3bHpqckppYmxRUUFvUTZ2MjRHNG1wY2cwN3VWTFhxN2JGMFZxMlJ2MWg4Qk51dGcvNjQw?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>GenerateSerialVersionUID</strong></p><p>Alt + Insert 快速生成SerialVersionUID<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9lUVB5QmZmWWJ1ZmVEUGY4MzkydkFqdHp6MzNMWGVjdzB1a2dxcEpHdFdpYjM1NzA1QmRiaFlkRkJwdGxvSXRDQlZUTG9MSEJQZmVFaWNaWE5Vb3dQVEFRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>GsonFormat</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2dpZi9lUVB5QmZmWWJ1ZmVEUGY4MzkydkFqdHp6MzNMWGVjd3B5Z2tOSzhmeERBQkN5aWFXQVVpYk15cGtDaDM5aWFxMlVFUHlHVzI0eWVEOFBPY25weG5ZQnlwZy82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>RestfulToolkit</strong></p><ul><li><p>快速跳转到Restful Api处( use: Ctrl(Command) + \ or Ctrl + Alt + N )</p></li><li><p>展示Resultful 接口结构</p></li><li><p>http 简单请求工具<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNrMWljeHNzc0pOaWNLaWI1VmliY3hLbDU3bW5NOFhjNFY4QmlhWUJhSGZrblpSdE9FQlpKWVNIQ05jUS82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p></li><li><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy96Nzl5SWJHQkVRQnNBZmo2WU9JMlNqdExKZHQzMnBkM0NOc0tZTHVWaWJsRXp2Vm01b1ZXVVVlZ0xQeG1DNUpwU0poR0pGVFhHd1NzZ0QzaWJsZEtMTFF3LzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"></p></li></ul><p><strong>Material Theme UI</strong></p><p>本人自用的主题就是这个。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNTdVNKdk5oYlhDOGxhN0Z4b2xpYUtyYUdGOHRhaldHMmxIR3RYbFcxcXhBYWEzM1ZTaWNKR29ody82NDA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>MyBatis Log Plugin</strong></p><p>把 Mybatis 输出的sql日志还原成完整的sql语句，看起来更直观。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9RQ3U4NDlZVGFJTUFDenU1RHYweWhpYzRHUldVSm1qUnNla0J5Y091UDY4WG1xeGliYnZUN3BaU1pDSEVXQUdFN1BpYzJ0OGliVWd5VWlhemY3a2JtaElPTVVRLzY0MA?x-oss-process=image/format,png" alt="在这里插入图片描述"><br><strong>Free Mybatis</strong></p><p>MyBatis 免费的插件</p><hr><p>参考</p><blockquote><p><a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial" target="_blank" rel="noopener">https://github.com/judasn/IntelliJ-IDEA-Tutorial</a></p></blockquote><p>(By the way, 更多IDEA使用请参考此延伸文档以及官方文档)</p><h1>（完）<h1></h1></h1>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Intelij IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴Java方向面试题汇总（含答案）</title>
      <link href="/2018/05/01/a-li-ba-ba-java-fang-xiang-mian-shi-ti-hui-zong-han-da-an/"/>
      <url>/2018/05/01/a-li-ba-ba-java-fang-xiang-mian-shi-ti-hui-zong-han-da-an/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里巴巴Java方向面试题汇总（含答案）"><a href="#阿里巴巴Java方向面试题汇总（含答案）" class="headerlink" title="阿里巴巴Java方向面试题汇总（含答案）"></a>阿里巴巴Java方向面试题汇总（含答案）</h1><p>涉及了从Java内置的基础数据结构、常用的服务器知识、Java网络编程相关的知识，再到Java的内存模型、Java常用编程框架等各个方面的内容，希望能够帮助大家回顾Java的基础内容，进而查漏补缺，完善自身的知识体系。</p><h2 id="一、String-StringBuffer-StringBuilder的区别是什么？String为什么是不可变的？"><a href="#一、String-StringBuffer-StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="一、String, StringBuffer, StringBuilder的区别是什么？String为什么是不可变的？"></a>一、String, StringBuffer, StringBuilder的区别是什么？String为什么是不可变的？</h2><ol><li>String是字符串常量，StringBuffer和StringBuilder都是字符串变量。后两者的字符内容可变，而前者创建后内容不可变。</li><li>String不可变是因为在JDK中String类被声明为一个final类。</li><li>StringBuffer是线程安全的，而StringBuilder是非线程安全的。</li></ol><p><strong>补充说明</strong>：线程安全会带来额外的系统开销，所以StringBuilder的效率比StringBuffer高。如果对系统中的线程是否安全很掌握，可用StringBuffer，在线程不安全处加上关键字Synchronize。</p><h2 id="二、Vector-ArrayList-LinkedList的区别是什么？"><a href="#二、Vector-ArrayList-LinkedList的区别是什么？" class="headerlink" title="二、Vector, ArrayList, LinkedList的区别是什么？"></a>二、Vector, ArrayList, LinkedList的区别是什么？</h2><ol><li>Vector、ArrayList都是以类似数组的形式存储在内存中，LinkedList则以链表的形式进行存储。</li><li>List中的元素有序、允许有重复的元素，Set中的元素无序、不允许有重复元素。</li><li>Vector线程同步，ArrayList、LinkedList线程不同步。</li><li>LinkedList适合指定位置插入、删除操作，不适合查找；ArrayList、Vector适合查找，不适合指定位置的插入、删除操作。</li><li>ArrayList在元素填满容器时会自动扩充容器大小的约50%，而Vector则是100%，因此ArrayList更节省空间。</li></ol><h2 id="三、HashTable-HashMap，-TreeMap的区别是什么？"><a href="#三、HashTable-HashMap，-TreeMap的区别是什么？" class="headerlink" title="三、HashTable, HashMap， TreeMap的区别是什么？"></a>三、HashTable, HashMap， TreeMap的区别是什么？</h2><ol><li>HashTable线程同步，HashMap非线程同步。</li><li>HashTable不允许&lt;键,值&gt;有空值，HashMap允许&lt;键,值&gt;有空值。</li><li>HashTable使用Enumeration，HashMap使用Iterator。</li><li>HashTable中hash数组的默认大小是11，增加方式的old*2+1，HashMap中hash数组的默认大小是16，增长方式一定是2的指数倍。</li><li>TreeMap能够把它保存的记录根据键排序，默认是按升序排序。</li></ol><p><strong>补充说明</strong>：以上三个问题所涉及的都是Java语言中的一些比较高级的数据结构，从字符串相关到容器再到哈希表和树等数据结构，因此我们在学习Java语言的时候，也需要更加深入地去对比比较类似的数据结构的使用场景以及其优缺点。</p><h2 id="四、Tomcat，Apache，JBoss的区别？"><a href="#四、Tomcat，Apache，JBoss的区别？" class="headerlink" title="四、Tomcat，Apache，JBoss的区别？"></a>四、Tomcat，Apache，JBoss的区别？</h2><ol><li>Apache是HTTP服务器，Tomcat是Web服务器，JBoss是应用服务器。</li><li>Apache解析静态的Html文件；Tomcat可解析jsp动态页面、也可充当</li><li>容器。</li></ol><p><strong>补充说明</strong>：对于服务器而言，在面试中可能并不会过多涉及，相对而言，面小易认为像是Liunx、Tomcat这些背后的原理可能更受面试官的青睐。</p><h2 id="五、GET，POST请求之间的区别？"><a href="#五、GET，POST请求之间的区别？" class="headerlink" title="五、GET，POST请求之间的区别？"></a>五、GET，POST请求之间的区别？</h2><pre><code>基础知识：HTTP的请求格式如下。主要包含三个信息：1、请求的类型（GET或POST），2、要访问的资源（如resimga.jif），3、HTTP版本（http/1.1）</code></pre><p><strong>区别：</strong></p><ol><li>Get是从服务器端获取数据，Post则是向服务器端发送数据。</li><li>在客户端，Get方式通过URL提交数据，在URL地址栏可以看到请求消息，该消息被编码过；Post数据则是放在Html header内提交。</li><li>对于Get方式，服务器端用Request.QueryString获取变量的值；对用Post方式，服务器端用Request.Form获取提交的数据值。</li><li>Get方式提交的数据最多1024字节，而Post则没有限制。</li><li>Get方式提交的参数及参数值会在地址栏显示，不安全，而Post不会，比较安全。</li></ol><h2 id="六、Session-Cookie的区别是什么？"><a href="#六、Session-Cookie的区别是什么？" class="headerlink" title="六、Session, Cookie的区别是什么？"></a>六、Session, Cookie的区别是什么？</h2><ol><li>Session由应用服务器维护的一个服务器端的存储空间；Cookie是客户端的存储空间，由浏览器维护。</li><li>用户可以通过浏览器设置决定是否保存Cookie，而不能决定是否保存Session，因为Session是由服务器端维护的。</li><li>Session中保存的是对象，Cookie中保存的是字符串。</li><li>Session和Cookie不能跨窗口使用，每打开一个浏览器系统会赋予一个SessionID，此时的SessionID不同，若要完成跨浏览器访问数据，可以使用 Application。</li><li>Session、Cookie都有失效时间，过期后会自动删除，减少系统开销。</li></ol><h2 id="七、HTTP-报文包含内容"><a href="#七、HTTP-报文包含内容" class="headerlink" title="七、HTTP 报文包含内容"></a>七、HTTP 报文包含内容</h2><p>主要包含四部分：</p><ol><li>request line</li><li>header line</li><li>blank line</li><li>request body</li></ol><p><strong>补充说明</strong>：上面的三个问题是网络编程的基础知识问题，作为Java工程师也需要掌握HTTP的知识，而如今HTTPS同样也成为了标准，也需要大家进一步了解。此外，相对于大家在课本或者课堂中所学习的HTTP 1.0/1.1这些协议而言，很多公司已经迈入了HTTP 2.0时代，因此两者之间的差别也需要我们进一步了解。</p><h2 id="八、Servlet的生命周期"><a href="#八、Servlet的生命周期" class="headerlink" title="八、Servlet的生命周期"></a>八、Servlet的生命周期</h2><p>大致分为4部：Servlet类加载–&gt;实例化–&gt;服务–&gt;销毁</p><p>Tomcat中Servlet的时序图如下所示：</p><p><img src="https://i.imgur.com/6t8q318.jpg" alt></p><ol><li>Web Client向Servlet容器(Tomcat)发出HTTP请求。</li><li>Servlet容器接收Client端的请求。</li><li>Servlet容器创建一个HttpRequest对象，将Client的请求信息封装到这个对象中。</li><li>Servlet创建一个HttpResponse对象。</li><li>Servlet调用HttpServlet对象的service方法，把HttpRequest对象和HttpResponse对象作为参数传递给HttpServlet对象中。</li><li>HttpServlet调用HttpRequest对象的方法，获取Http请求，并进行相应处理。</li><li>处理完成HttpServlet调用HttpResponse对象的方法，返回响应数据。</li><li>Servlet容器把HttpServlet的响应结果传回客户端。</li></ol><p>其中的3个方法说明了Servlet的生命周期：</p><ol><li>init()：负责初始化Servlet对象。</li><li>service()：负责响应客户端请求。</li><li>destroy()：当Servlet对象推出时，负责释放占用资源。</li></ol><h2 id="九、Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入？"><a href="#九、Statement与PreparedStatement的区别-什么是SQL注入，如何防止SQL注入？" class="headerlink" title="九、Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入？"></a>九、Statement与PreparedStatement的区别,什么是SQL注入，如何防止SQL注入？</h2><ol><li>PreparedStatement支持动态设置参数，Statement不支持。</li><li>PreparedStatement可避免如类似 单引号 的编码麻烦，Statement不可以。</li><li>PreparedStatement支持预编译，Statement不支持。</li><li>在SQL语句出错时PreparedStatement不易检查，而Statement则更便于查错。</li><li>PreparedStatement可防止SQL助于，更加安全，而Statement不行。</li></ol><p><strong>补充说明-什么是SQL注入以及应对策略：</strong> 通过SQL语句的拼接达到无参数查询数据库数据目的的方法。如将要执行的SQL语句为 select * from table where name = “+appName+”，利用appName参数值的输入，来生成恶意的SQL语句，如将[‘or’1’=‘1’] 传入可在数据库中执行。因此可以采用PrepareStatement来避免SQL注入，在服务器端接收参数数据后，进行验证，此时PrepareStatement会自动检测，而Statement不行，需要手工检测。</p><h2 id="十、sendRedirect-foward区别"><a href="#十、sendRedirect-foward区别" class="headerlink" title="十、sendRedirect, foward区别"></a>十、sendRedirect, foward区别</h2><ol><li>foward是服务器端控制页面转向，在客户端的浏览器地址中不会显示转向后的地址；sendRedirect则是完全的跳转，浏览器中会显示跳转的地址并重新发送请求链接。原理：forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后再将这些内容返回给浏览器，浏览器根本不知道服务器发送的这些内容是从哪来的，所以地址栏还是原来的地址。</li><li>redirect是服务器端根据逻辑，发送一个状态码，告诉浏览器重新去请求的那个地址，浏览器会用刚才的所有参数重新发送新的请求。</li></ol><p><strong>补充说明</strong>：以上的三个问题在之前网络相关的知识上更进一步，上升到了Java网络编程的相关知识，这部分意在考察面试者对于Java网络编程相关知识的掌握程度。</p><h2 id="十一、谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？"><a href="#十一、谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？" class="headerlink" title="十一、谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？"></a>十一、谈谈Hibernate的理解，一级和二级缓存的作用，在项目中Hibernate都是怎么使用缓存的？</h2><p>Hibernate是一个开发的对象关系映射框架（ORM）。它对JDBC进行了非常对象封装，Hibernate允许程序员采用面向对象的方式来操作关系数据库。</p><p><strong>Hibernate的优点：</strong></p><ol><li>程序更加面向对象</li><li>提高了生产率</li><li>方便移植</li><li>无入侵性</li></ol><p><strong>Hibernate的缺点：</strong></p><ol><li>效率比JDBC略差</li><li>不适合批量操作</li><li>只能配置一种关联关系</li></ol><p><strong>Hibernate有四种查询方式：</strong></p><ol><li>get、load方法，根据ID号查询对象。</li><li>Hibernate Query Language, HQL</li><li>标准查询语言</li><li>通过SQL查询</li></ol><p><strong>Hibernate工作原理：</strong></p><ol><li>配置Hibernate对象关系映射文件、启动服务器</li><li>服务器通过实例化Configuration对象，读取hibernate.cfg.xml文件的配置内容，并根据相关的需求建好表以及表之间的映射关系。</li><li>通过实例化的Configuration对象建立SessionFactory实例，通过SessionFactory实例创建Session对象。</li><li>通过Session对象完成数据库的增删改查操作。</li></ol><p><strong>Hibernate中的状态转移：</strong></p><p><em>临时状态（Transient）</em></p><ol><li>不处于SESSION缓存中</li><li>数据库中没有对象记录</li></ol><p><strong>补充说明-Java是如何进入临时状态的：</strong>1、通过new语句创建一个对象时。2、刚调用Session的delete()方法时，从Session缓存中删除一个对象时。</p><p><em>持久化状态(Persisted)</em><br>1、处于Session缓存中<br>2、持久化对象数据库中没有对象记录<br>3、Session在特定的时刻会保存两者同步</p><p>补<strong>充说明-Java如何进入持久化状态</strong>：1、Session的save()方法。2、Session的load().get()方法返回的对象。3、Session的find()方法返回的list集合中存放的对象。4、Session的update().save()方法。</p><p><em>流离状态（Detached）</em><br>1、不再位于Session缓存中<br>2、游离对象由持久化状态转变而来，数据库中还没有相应记录。</p><p><strong>补充说明-Java如何进入流离状态：</strong></p><p>1、Session的close()。2、 Session的evict()方法，从缓存中删除一个对象。</p><p>具体如下图所示：<br><img src="https://i.imgur.com/StmlgBX.png" alt></p><p>Hibernate中的缓存主要有Session缓存（一级缓存）和SessionFactory缓存（二级缓存，一般由第三方提供）。</p><h2 id="十二、谈谈Hibernate与iBatis的区别，哪个性能会更高一些"><a href="#十二、谈谈Hibernate与iBatis的区别，哪个性能会更高一些" class="headerlink" title="十二、谈谈Hibernate与iBatis的区别，哪个性能会更高一些"></a>十二、谈谈Hibernate与iBatis的区别，哪个性能会更高一些</h2><ol><li>Hibernate偏向于对象的操作达到数据库相关操作的目的；而iBatis更偏向于SQL语句的优化。</li><li>Hibernate的使用的查询语句是自己的HQL，而iBatis则是标准的SQL语句。</li><li>Hibernate相对复杂，不易学习；iBatis类似SQL语句，简单易学。</li></ol><p><strong>性能方面：</strong></p><ol><li>如果系统数据处理量巨大，性能要求极为苛刻时，往往需要人工编写高性能的SQL语句或存错过程，此时iBatis具有更好的可控性，因此性能优于Hibernate。</li><li>同样的需求下，由于Hibernate可以自动生成HQL语句，而iBatis需要手动写SQL语句，此时采用Hibernate的效率高于iBatis。</li></ol><h2 id="十三、对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。"><a href="#十三、对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。" class="headerlink" title="十三、对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。"></a>十三、对Spring的理解，项目中都用什么？怎么用的？对IOC、和AOP的理解及实现原理。</h2><p>Spring是一个开源框架，处于MVC模式中的控制层，它能应对需求快速的变化，其主要原因它有一种面向切面编程（AOP）的优势，其次它提升了系统性能，因为通过依赖倒置机制（IOC），系统中用到的对象不是在系统加载时就全部实例化，而是在调用到这个类时才会实例化该类的对象，从而提升了系统性能。这两个优秀的性能使得Spring受到许多J2EE公司的青睐，如阿里中使用最多的也是Spring相关技术。</p><p><strong>Spring的优点：</strong></p><ol><li>降低了组件之间的耦合性，实现了软件各层之间的解耦。</li><li>可以使用容易提供的众多服务，如事务管理，消息服务，日志记录等。</li><li>容器提供了AOP技术，利用它很容易实现如权限拦截、运行期监控等功能。</li></ol><p>Spring中AOP技术是设计模式中的动态代理模式。只需实现jdk提供的动态代理接口InvocationHandler，所有被代理对象的方法都由InvocationHandler接管实际的处理任务。面向切面编程中还要理解切入点、切面、通知、织入等概念。</p><p>Spring中IOC则利用了Java强大的反射机制来实现。所谓依赖注入即组件之间的依赖关系由容器在运行期决定。其中依赖注入的方法有两种，通过构造函数注入，通过set方法进行注入。</p><h2 id="十四、描述Struts的工作流程"><a href="#十四、描述Struts的工作流程" class="headerlink" title="十四、描述Struts的工作流程"></a>十四、描述Struts的工作流程</h2><ol><li>在web应用启动时，加载并初始化ActionServlet，ActionServlet从struts-config.xml文件中读取配置信息，将它们存放到各个配置对象中。</li><li>当ActionServlet接收到一个客户请求时，首先检索和用户请求相匹配的ActionMapping实例，如果不存在，就返回用户请求路径无效信息。</li><li>如果ActionForm实例不存在，就创建一个ActionForm对象，把客户提交的表单数据保存到ActionForm对象中。</li><li>根据配置信息决定是否需要验证表单，如果需要，就调用ActionForm的validate()方法，如果ActionForm的validate()方法返回null或返回一个不包含ActionMessage的ActionErrors对象，就表示表单验证成功。</li><li>ActionServlet根据ActionMapping实例包含的映射信息决定请求转发给哪个Action，如果相应的Action实例不存在，就先创建一个实例，然后调用Action的execute()方法。</li></ol><p><strong>补充说明</strong>：以上部分的相关问题考察面试者在实际软件开发中所使用的Java语言相关框架以及对于框架原理的了解程度，这一部分我们需要注意一些常见的框架，不仅需要知道它们是干什么的，还需要知道它们背后的原理，常会问到的框架有Spring Boot/Spring Cloud全家桶、Hibernate、MyBaits、Netty、Kafka等，最重要的还有阿里巴巴开源的Apache Dubbo框架。</p><h2 id="十五、关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果-属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份-。"><a href="#十五、关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果-属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份-。" class="headerlink" title="十五、关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果 属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份 ##。"></a>十五、关于Java内存模型，一个对象（两个属性，四个方法）实例化100次，现在内存中的存储状态，几个对象，几个属性，几个方法。由于Java中new出来的对象都是放在堆中，所以如果要实例化100次，将在堆中产生100个对象，一般对象与其中的属性、方法都属于一个整体，但如果 属性和方法是静态的，就是用static关键字声明的，那么属于类的属性和方法永远只在内存中存在一份 ##。</h2><h2 id="十六、反射讲一讲，主要是概念-都在哪需要反射机制，反射的性能，如何优化？"><a href="#十六、反射讲一讲，主要是概念-都在哪需要反射机制，反射的性能，如何优化？" class="headerlink" title="十六、反射讲一讲，主要是概念,都在哪需要反射机制，反射的性能，如何优化？"></a>十六、反射讲一讲，主要是概念,都在哪需要反射机制，反射的性能，如何优化？</h2><p><strong>反射机制的定义：</strong></p><p>是在运行状态中，对于任意的一个类，都能够知道这个类的所有属性和方法，对任意一个对象都能够通过反射机制调用一个类的任意方法，这种动态获取类信息及动态调用类对象方法的功能称为java的反射机制。</p><p><strong>反射的作用：</strong></p><ol><li>动态地创建类的实例，将类绑定到现有的对象中，或从现有的对象中获取类型。</li><li>应用程序需要在运行时从某个特定的程序集中载入一个特定的类。</li></ol><h2 id="十七、线程同步，并发操作怎么控制？"><a href="#十七、线程同步，并发操作怎么控制？" class="headerlink" title="十七、线程同步，并发操作怎么控制？"></a>十七、线程同步，并发操作怎么控制？</h2><p>Java中可在方法名前加关键字syschronized来处理当有多个线程同时访问共享资源时候的问题。syschronized相当于一把锁，当有申请者申请该资源时，如果该资源没有被占用，那么将资源交付给这个申请者使用，在此期间，其他申请者只能申请而不能使用该资源，当该资源被使用完成后将释放该资源上的锁，其他申请者可申请使用。并发控制主要是为了多线程操作时带来的资源读写问题。如果不加以空间可能会出现死锁，读脏数据、不可重复读、丢失更新等异常。</p><p><strong>并发操作可以通过加锁的方式进行控制，锁又可分为乐观锁和悲观锁。</strong></p><p><strong>悲观锁：</strong></p><p>悲观锁并发模式假定系统中存在足够多的数据修改操作，以致于任何确定的读操作都可能会受到由个别的用户所制造的数据修改的影响。也就是说悲观锁假定冲突总会发生，通过独占正在被读取的数据来避免冲突。但是独占数据会导致其他进程无法修改该数据，进而产生阻塞，读数据和写数据会相互阻塞。</p><p><strong>乐观锁：</strong></p><p>乐观锁假定系统的数据修改只会产生非常少的冲突，也就是说任何进程都不大可能修改别的进程正在访问的数据。乐观并发模式下，读数据和写数据之间不会发生冲突，只有写数据与写数据之间会发生冲突。即读数据不会产生阻塞，只有写数据才会产生阻塞。</p><p><strong>补充说明</strong>：最后的几个问题又回到了Java内存模型以及进程、线程的底层知识上，其实无论是对于Java网络编程也好，还是对于Java框架的使用也好，这都离不开Java语言底层的技术支撑，因此了解底层知识是做好优化的重中之重。</p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何把更新后的项目重新传到github上</title>
      <link href="/2018/04/23/ru-he-ba-geng-xin-hou-de-xiang-mu-chong-xin-chuan-dao-github-shang/"/>
      <url>/2018/04/23/ru-he-ba-geng-xin-hou-de-xiang-mu-chong-xin-chuan-dao-github-shang/</url>
      
        <content type="html"><![CDATA[<h2 id="以后更新项目基本上就是使用下面这几条命令就行："><a href="#以后更新项目基本上就是使用下面这几条命令就行：" class="headerlink" title="以后更新项目基本上就是使用下面这几条命令就行："></a>以后更新项目基本上就是使用下面这几条命令就行：</h2><p>自己主要是更新github上的项目所以刚开始上传请看下面转自某位大神的博客，但是如果是更新github上面的项目就比较简单。</p><ol><li><p>在本地的git仓库把你更新好的项目拷到下面然后打开命令行<img src="https://img-blog.csdn.net/20180528205558250" alt></p></li><li><p>使用下面命令就行</p><ul><li>git status</li><li>git add . </li><li>git commit -m “本次更新的说明”</li><li>git push origin master # 将本地主分支推到远程主分支<br><img src="https://img-blog.csdn.net/20180528224516824" alt></li></ul><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><p>查看、添加、提交、删除、找回，重置修改文件</p><p>git help <command> # 显示command的help</p><p>git show # 显示某次提交的内容 git show $id</p><p>git co -<file> # 抛弃工作区修改</file></p><p>git co . # 抛弃工作区修改</p><p>git add <file> # 将工作文件修改提交到本地暂存区</file></p><p>git add . # 将所有修改过的工作文件提交暂存区</p><p>git rm <file> # 从版本库中删除文件</file></p><p>git rm <file> –cached # 从版本库中删除文件，但不删除文件</file></p><p>git reset <file> # 从暂存区恢复到工作文件</file></p><p>git reset -. # 从暂存区恢复到工作文件</p><p>git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</p><p>git ci <file> git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做git ci -am “some comments”</file></p><p>git ci –amend # 修改最后一次提交记录</p><p>git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</p><p>git revert HEAD # 恢复最后一次提交的状态</p></li></ol><h2 id="查看文件diff"><a href="#查看文件diff" class="headerlink" title="查看文件diff"></a>查看文件diff</h2><pre><code>-     git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diff-      -     git diff &lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异-      -     git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较-      -     git diff --staged # 比较暂存区和版本库差异-      -     git diff --cached # 比较暂存区和版本库差异-      -     git diff --stat # 仅仅比较统计信息</code></pre><h2 id="查看提交记录"><a href="#查看提交记录" class="headerlink" title="查看提交记录"></a>查看提交记录</h2><pre><code>-     git log git log &lt;file&gt; # 查看该文件每次提交记录-      -     git log -p &lt;file&gt; # 查看每次详细修改内容的diff-      -     git log -p -2 # 查看最近两次详细修改内容的diff-      -     git log --stat #查看提交统计信息</code></pre><p>tig</p><p><strong>Mac上可以使用tig代替diff和log，brew install tig</strong></p><h2 id="Git-本地分支管理"><a href="#Git-本地分支管理" class="headerlink" title="Git 本地分支管理"></a>Git 本地分支管理</h2><p>查看、切换、创建和删除分支</p><pre><code>-     git br -r # 查看远程分支-      -     git br &lt;new_branch&gt; # 创建新的分支-      -     git br -v # 查看各个分支最后提交信息-      -     git br --merged # 查看已经被合并到当前分支的分支-      -     git br --no-merged # 查看尚未被合并到当前分支的分支-      -     git co &lt;branch&gt; # 切换到某个分支-      -     git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去-      -     git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch-      -     git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除-      -     git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支-      -     git br -d &lt;branch&gt; # 删除某个分支-      -     git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</code></pre><h2 id="分支合并和rebase"><a href="#分支合并和rebase" class="headerlink" title="分支合并和rebase"></a>分支合并和rebase</h2><pre><code>git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git</code></pre><h2 id="Git补丁管理"><a href="#Git补丁管理" class="headerlink" title="Git补丁管理"></a>Git补丁管理</h2><p>(方便在多台机器上开发同步时用)<br>    git diff &gt; ../sync.patch # 生成补丁</p><pre><code>git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功</code></pre><h2 id="Git暂存管理"><a href="#Git暂存管理" class="headerlink" title="Git暂存管理"></a>Git暂存管理</h2><pre><code>git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上</code></pre><h2 id="git-push-push所有分支"><a href="#git-push-push所有分支" class="headerlink" title="git push (push所有分支)"></a>git push (push所有分支)</h2><pre><code>git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</code></pre><h2 id="Git远程仓库管理"><a href="#Git远程仓库管理" class="headerlink" title="Git远程仓库管理"></a>Git远程仓库管理</h2><pre><code>git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址</code></pre><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><pre><code>git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支</code></pre><p><strong>也可以命令设置跟踪远程库和本地库</strong></p><pre><code>git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop</code></pre>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用github部署网站</title>
      <link href="/2018/04/23/shi-yong-github-bu-shu-wang-zhan/"/>
      <url>/2018/04/23/shi-yong-github-bu-shu-wang-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="使用GitHub部署网站"><a href="#使用GitHub部署网站" class="headerlink" title="使用GitHub部署网站"></a>使用GitHub部署网站</h1><p><strong>在部署网站之前，先要有一个GitHub账号，熟悉一些git命令，注册GitHub账号和使用git命令可以参考下面的博客，在博客中介绍的非常详细，我也不做过多的介绍</strong></p><hr>从0开始学习GitHub系列汇总：[http://pan.baidu.com/s/1hsn57YO](http://pan.baidu.com/s/1hsn57YO)<p>注册好GitHub账号并且完善用户信息后可以得到一个下图所示的界面，下图是我的GitHub界面，其中界面中的信息介绍可以参考，<code>从0开始学习 GITHUB 系列之「加入 GITHUB」</code>这篇博客对GitHub界面的信息介绍的非常详细</p><p><img src="https://i.imgur.com/rnbszof.png" alt></p><p>在GitHub上部署网站：</p><p><strong>第一步</strong>：单击Repositories，其中Repositories在GitHub上表示的是仓库，在GitHub上每个项目都存放在仓库里，一个仓库保存一个项目<br><img src="https://i.imgur.com/pPjslYS.jpg" alt></p><p><strong>第二步</strong>：单击根据图中的提示填写信息，信息填写完成后单击Create respository按钮创建仓库<br><img src="https://i.imgur.com/zjbd2WZ.jpg" alt></p><p><strong>第三步</strong>：单击创建好仓库后会自动跳转到下图所示的界面，在界面中单击Settings<br><img src="https://i.imgur.com/KdK0YwY.jpg" alt></p><p><strong>第四步</strong>：提示在下面的操作中需要电脑中安装了git，并且熟悉几个简单的git命令，关于git的安装以及git命令的使用可以参考<code>从0开始学习 GITHUB 系列之「GIT 速成」</code>，这篇博客将git介绍的非常通俗易懂，安装好git后，先在电脑中创建一个文件夹用于保存从Github中克隆下来的仓库，我建的文件夹叫做demo，在d:\Git路径下，打开命令行进入demo文件夹下<br><img src="https://i.imgur.com/T8eLnrI.png" alt><br><strong>第五步</strong>在 命令行中执行<code>https://github.com/leblog/test.git</code>命令</p><p>其中<code>git clone</code>表示要克隆一个项目，后面的<code>https://github.com/leblog/test.git</code>表示项目地址，该地址是由第十二步操作获得的，当在最后一行出现了100%表示，远程仓库已经成功的克隆到了本地<br><img src="https://i.imgur.com/OIRdznD.png" alt><br><strong>第六步</strong>：打开demo文件夹，可以看到在文件夹中多了一个test文件，该文件正是刚刚在GitHub中创建的仓库</p><p><img src="https://i.imgur.com/UnaGLvt.png" alt><br><strong>第七步</strong>：打开文件，并且将需要上传到GitHub上的网站添加到该文件中<br><img src="https://i.imgur.com/6nWYnck.png" alt><br><strong>第八步</strong>：打开命令行，并且进入test文件夹下，并且执行 <code>git add .</code>命令，此命令表示将需要提交到git中的文件先添加到缓存<br><img src="https://i.imgur.com/N5bRudR.png" alt><br><strong>第九步</strong>：执行 <code>git commit -m &quot;first commit .&quot;</code>，此命令表示将文件提交到git中，下面显示的都是提交到git中的文件</p><p><img src="https://i.imgur.com/dopR8lM.png" alt><br><strong>第十步</strong>：执行<code>git push origin master</code>命令，将文件<code>push</code>到GitHub上的master分支上，当出现下图所示的提示信息时，表示网站已经成功的提交到了GitHub上<br><img src="https://i.imgur.com/yM8aV3c.png" alt><br><strong>第十一步</strong>：回到Github上的test仓库，可以看到文件已经全部提交上来了</p><hr>通过观察网址可知，网址的格式为 https:// + GitHub的用户名 + .github.io/ + 仓库的名称<p><img src="https://i.imgur.com/xhbPnpJ.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试知识浅谈</title>
      <link href="/2018/04/12/ce-shi-zhi-shi-qian-tan/"/>
      <url>/2018/04/12/ce-shi-zhi-shi-qian-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="TDD测试"><a href="#TDD测试" class="headerlink" title="TDD测试"></a>TDD测试</h1><ul><li>TDD测试驱动编程，编程方法，编程思想</li><li>先写测试，再编写业务代码</li><li>源码里编码，CRUD<blockquote><p>   crud是指在做计算处理时的增加(Create)、读取(Read)、更新(Update)和删除(Delete)几个单词的首字母简写。crud主要被用在描述软件系统中数据库或者持久层的基本操作功能。</p></blockquote></li></ul><pre><code>User    Save    del    edit    selectUserservice</code></pre><h1 id="DDD-领域驱动设计"><a href="#DDD-领域驱动设计" class="headerlink" title="DDD  领域驱动设计"></a>DDD  领域驱动设计</h1><p>测试本身也是一套完整的学科</p><hr><ul><li><p>单元测试</p><ul><li>白盒测试 能看到完整代码的</li><li>黑盒测试 没有源码功能测试</li><li>灰盒测试  </li></ul></li><li><p>压力测试</p><ul><li>并发数的问题，能够承载多少的并发</li></ul></li><li><p>疲劳强度测试</p><ul><li>长期稳定运行，超过72小时，</li></ul></li><li><p>冒烟测试</p><ul><li>对主要流程的测试，支付环节</li><li>对一个功能点疯狂的测试</li></ul></li><li><p>集成测试</p><ul><li>完整功能的测试，最重要的是测试整体业务流程</li></ul></li><li><p>回归测试</p><ul><li>增加一个功能</li></ul></li><li><p>自动化测试</p><ul><li>编码,场景设计</li></ul></li><li><p>review</p><ul><li>代码评审</li><li>电商 B2B2C   eg:如果你是天猫的程序员，去京东去工作，试想一下，如果你在京东其程序中添加后门，双十一让网站停止5分钟，后果不堪设想</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JUint </tag>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUint单元测试</title>
      <link href="/2018/04/12/juint-dan-yuan-ce-shi/"/>
      <url>/2018/04/12/juint-dan-yuan-ce-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JUnit 是用于编写和运行可重复的自动化测试的开源测试框架，这样可以保证我们的代码按预期工作。</p><p>JUnit 可广泛用于工业和作为支架(从命令行)或IDE(如 IDEA)内单独的 Java 程序。</p><p>JUnit 提供：</p><ul><li><p>断言测试预期结果。</p></li><li><p>测试功能共享通用的测试数据。</p></li><li><p>测试套件轻松地组织和运行测试。</p></li><li><p>图形和文本测试运行。</p><h3 id="JUnit-用于测试："><a href="#JUnit-用于测试：" class="headerlink" title="JUnit 用于测试："></a>JUnit 用于测试：</h3></li><li><p>整个对象</p></li><li><p>对象的一部分 - 交互的方法或一些方法</p></li><li><p>几个对象之间的互动(交互)</p></li></ul><h3 id="JUnit-特点"><a href="#JUnit-特点" class="headerlink" title="JUnit 特点"></a>JUnit 特点</h3><ul><li>JUnit 是用于编写和运行测试的开源框架。</li><li>提供了注释，以确定测试方法。</li><li>提供断言测试预期结果。</li><li>提供了测试运行的运行测试。</li><li>JUnit 测试让您可以更快地编写代码，提高质量</li><li>JUnit 是优雅简洁。它是不那么复杂以及不需要花费太多的时间。</li><li>JUnit 测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。</li><li>JUnit 测试可以组织成测试套件包含测试案例，甚至其他测试套件。</li><li>Junit 显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。</li></ul><h1 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h1><p><code>pom.xml</code>文件如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.funtl&lt;/groupId&gt;    &lt;artifactId&gt;hello-spring&lt;/artifactId&gt;    &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><p>主要增加了 junit:junit 依赖</p><h3 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h3><p>在测试包下 <code>src/main/test</code> 创建一个名为 <code>MyTest</code> 的测试类，代码如下：</p><pre><code>package com.funtl.hello.spring.test;import org.junit.After;import org.junit.Before;import org.junit.Test;public class MyTest {    /**     * 执行测试方法前执行     */    @Before    public void before() {        System.out.println(&quot;执行 before() 方法&quot;);    }    /**     * 执行测试方法后执行     */    @After    public void after() {        System.out.println(&quot;执行 after() 方法&quot;);    }    @Test    public void testSayHi() {        System.out.println(&quot;Hi Log4j&quot;);    }    @Test    public void testSayHello() {        System.out.println(&quot;Hello Log4j&quot;);    }}</code></pre><h1 id="JUnit-注解"><a href="#JUnit-注解" class="headerlink" title="JUnit 注解"></a>JUnit 注解</h1><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td><code>@Test</code> <br> public void method()</td><td>测试注释指示该公共无效方法它所附着可以作为一个测试用例。</td></tr><tr><td><code>@Before</code> <br> public void method()</td><td>Before 注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。</td></tr><tr><td><code>@BeforeClass</code><br> public static void method()</td><td>BeforeClass 注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。</td></tr><tr><td><code>@After</code> <br> public void method()</td><td>After 注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等)</td></tr><tr><td></td><td></td></tr><tr><td><code>@AfterClass</code><br> public static void method()</td><td>当需要执行所有的测试在 JUnit 测试用例类后执行，AfterClass 注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于 BeforeClass)的方法必须定义为静态</td></tr><tr><td></td><td></td></tr><tr><td><code>@Ignore</code>  <br>public static void method()</td><td>当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为 @Ignore 的方法将不被执行。</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="JUnit-断言"><a href="#JUnit-断言" class="headerlink" title="JUnit 断言"></a>JUnit 断言</h1><h3 id="什么是断言"><a href="#什么是断言" class="headerlink" title="什么是断言"></a>什么是断言</h3><blockquote><p>  断言是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新启用断言。</p></blockquote><p>使用断言可以创建更稳定、品质更好且 不易于出错的代码。当需要在一个值为 false 时中断当前操作的话，可以使用断言。单元测试必须使用断言（Junit/JunitX）。</p><h3 id="常用断言方法"><a href="#常用断言方法" class="headerlink" title="常用断言方法"></a>常用断言方法</h3><hr><table><thead><tr><th>断言</th><th>描述</th></tr></thead><tbody><tr><td>void assertEquals([String message], <br>expected value, actual value)</td><td>断言两个值相等。值可能是类型有 int, short, long,<br> byte, char or java.lang.Object. 第一个参数是一个可选的字符串消息</td></tr><tr><td>void assertTrue([String message],<br> boolean condition)</td><td>断言一个条件为真</td></tr><tr><td>void assertFalse([String message]<br>,boolean condition)</td><td>断言一个条件为假</td></tr><tr><td>void assertNotNull([String message],<br> java.lang.Object object)</td><td>断言一个对象不为空(null)</td></tr><tr><td>void assertNull([String message], <br>java.lang.Object object)</td><td>断言一个对象为空(null)</td></tr><tr><td>void assertSame([String message],<br> java.lang.Object expected,<br> java.lang.Object actual)</td><td>断言，两个对象引用相同的对象</td></tr><tr><td>void assertNotSame([String message],<br> java.lang.Object unexpected,<br> java.lang.Object actual)</td><td>断言，两个对象不是引用同一个对象</td></tr><tr><td>void assertArrayEquals([String message],<br> expectedArray, resultArray)</td><td>断言预期数组和结果数组相等。数组的类型可能是 int, long, short, char, byte or java.lang.Object.</td></tr></tbody></table><h3 id="测试断言效果"><a href="#测试断言效果" class="headerlink" title="测试断言效果"></a>测试断言效果</h3><hr>在之前的单元测试类中创建一个名为 `testAssert` 方法来查看断言效果<pre><code>/** * 测试断言 */@Testpublic void testAssert() {    String obj1 = &quot;junit&quot;;    String obj2 = &quot;junit&quot;;    String obj3 = &quot;test&quot;;    String obj4 = &quot;test&quot;;    String obj5 = null;    int var1 = 1;    int var2 = 2;    int[] arithmetic1 = {1, 2, 3};    int[] arithmetic2 = {1, 2, 3};    assertEquals(obj1, obj2);    assertSame(obj3, obj4);    assertNotSame(obj2, obj4);    assertNotNull(obj1);    assertNull(obj5);    assertTrue(&quot;为真&quot;, var1 == var2);    assertArrayEquals(arithmetic1, arithmetic2);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JAVA </tag>
            
            <tag> JUint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bootstrap之网格系统</title>
      <link href="/2018/04/03/bootstrap-zhi-wang-ge-xi-tong/"/>
      <url>/2018/04/03/bootstrap-zhi-wang-ge-xi-tong/</url>
      
        <content type="html"><![CDATA[<h1 id="Bootstrap网格系统"><a href="#Bootstrap网格系统" class="headerlink" title="Bootstrap网格系统"></a>Bootstrap网格系统</h1><p><strong>Bootstrap 提供了一套响应式、移动设备优先的流式网格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自分为最多12列。</strong></p><hr><h1 id="什么是网格（Grid）？"><a href="#什么是网格（Grid）？" class="headerlink" title="什么是网格（Grid）？"></a>什么是网格（Grid）？</h1><p>摘自维基百科：</p><blockquote><p>在平面设计中，网格是一种由一系列用于组织内容的相交的直线（垂直的、水平的）组成的结构（通常是二维的）。它广泛应用于打印设计中的设计布局和内容结构。在网页设计中，它是一种用于快速创建一致的布局和有效地使用 HTML 和 CSS 的方法。</p></blockquote><p>简单地说，网页设计中的网格用于组织内容，让网站易于浏览，并降低用户端的负载。</p><hr><h1 id="什么是-Bootstrap-网格系统（Grid-System）？"><a href="#什么是-Bootstrap-网格系统（Grid-System）？" class="headerlink" title="什么是 Bootstrap 网格系统（Grid System）？"></a>什么是 Bootstrap 网格系统（Grid System）？</h1><blockquote><p>Bootstrap 包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到 12 列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类。</p></blockquote><p>让我们来理解一下上面的语句。Bootstrap 3 是移动设备优先的，在这个意义上，Bootstrap 代码从小屏幕设备（比如移动设备、平板电脑）开始，然后扩展到大屏幕设备（比如笔记本电脑、台式电脑）上的组件和网格。</p><h3 id="移动设备优先策略"><a href="#移动设备优先策略" class="headerlink" title="移动设备优先策略"></a>移动设备优先策略</h3><ul><li>内容<ul><li>决定什么是最重要的。</li></ul></li><li>布局<ul><li>优先设计更小的宽度。</li><li>基础的 CSS 是移动设备优先，媒体查询是针对于平板电脑、台式电脑。</li></ul></li><li>渐进式增强<ul><li>随着屏幕大小的增加而添加元素。</li></ul></li></ul><p>响应式网格系统随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列。</p><table><thead><tr><th>name</th><th>价格</th><th>数量</th><th>name</th><th>价格</th><th>数量</th><th>name</th><th>价格</th><th>数量</th><th>name</th><th>价格</th><th>数量</th></tr></thead><tbody><tr><td>香蕉</td><td>$1</td><td>5</td><td>香蕉</td><td>$1</td><td>5</td><td>香蕉</td><td>$1</td><td>5</td><td>香蕉</td><td>$1</td><td>5</td></tr><tr><td>苹果</td><td>$1</td><td>6</td><td>苹果</td><td>$1</td><td>6</td><td>苹果</td><td>$1</td><td>6</td><td>苹果</td><td>$1</td><td>6</td></tr><tr><td>草莓</td><td>$1</td><td>7</td><td>草莓</td><td>$1</td><td>7</td><td>草莓</td><td>$1</td><td>7</td><td>草莓</td><td>$1</td><td>7</td></tr></tbody></table><h1 id="Bootstrap-网格系统（Grid-System）的工作原理"><a href="#Bootstrap-网格系统（Grid-System）的工作原理" class="headerlink" title="Bootstrap 网格系统（Grid System）的工作原理"></a>Bootstrap 网格系统（Grid System）的工作原理</h1><p>网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的：</p><pre><code>- 行必须放置在 .container class 内，以便获得适当的对齐（alignment）和内边距（padding）。- 使用行来创建列的水平组。- 内容应该放置在列内，且唯有列可以是行的直接子元素。- 预定义的网格类，比如 .row 和 .col-xs-4，可用于快速创建网格布局。LESS 混合类可用于更多语义布局。- 列通过内边距（padding）来创建列内容之间的间隙。该内边距是通过 .rows 上的外边距（margin）取负，表示第一列和最后一列的行偏移。- 网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个 .col-xs-4。</code></pre><h1 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h1><p>媒体查询是非常别致的”有条件的 CSS3 规则”。它只适用于一些基于某些规定条件的 CSS。如果满足那些条件，则应用相应的样式。</p><p>Bootstrap 中的媒体查询允许您基于视口大小移动、显示并隐藏内容。下面的媒体查询在 LESS 文件中使用，用来创建 Bootstrap 网格系统中的关键的分界点阈值。</p><blockquote><p> /<em> 超小设备（手机，小于 768px） </em>/<br>    /<em> Bootstrap 中默认情况下没有媒体查询 </em>/<br> /<em> 小型设备（平板电脑，768px 起） </em>/<br>@media (min-width: @screen-sm-min) { … }<br> /<em> 中型设备（台式电脑，992px 起） </em>/<br>@media (min-width: @screen-md-min) { … }<br> /<em> 大型设备（大台式电脑，1200px 起） </em>/<br>@media (min-width: @screen-lg-min) { … }<br>我们有时候也会在媒体查询代码中包含 max-width，从而将 CSS 的影响限制在更小范围的屏幕大小之内。<br>      @media (max-width: @screen-xs-max) { … }<br>      @media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { … }<br>      @media (min-width: @screen-md-min) and (max-width: @screen-md-max) { … }<br>      @media (min-width: @screen-lg-min) { … }<br>媒体查询有两个部分，先是一个设备规范，然后是一个大小规则。在上面的案例中，设置了下列的规则：<br>让我们来看下面这行代码：</p></blockquote><pre><code>@media (min-width: @screen-sm-min) and (max-width: @screen-sm-max) { ... }</code></pre><p>对于所有带有 min-width: @screen-sm-min 的设备，如果屏幕的宽度小于 @screen-sm-max，则会进行一些处理。</p><h1 id="网格选项"><a href="#网格选项" class="headerlink" title="网格选项"></a>网格选项</h1><p>下表总结了 Bootstrap 网格系统如何跨多个设备工作：</p><pre><code>超小设备手机（&lt;768px）    小型设备平板电脑（≥768px）    中型设备台式电脑（≥992px）    大型设备台式电脑（≥1200px）</code></pre><table><thead><tr><th>超小设备手机（&lt;768px）</th><th>小型设备平板电脑（≥768px）</th><th>中型设备台式电脑（≥992px）</th><th>大型设备台式电脑（≥1200px）</th></tr></thead><tbody><tr><td>网格行为</td><td>一直是水平的</td><td>以折叠开始，断点以上是水平的</td><td>以折叠开始，断点以上是水平的</td></tr><tr><td>最大容器宽度</td><td>None (auto)</td><td>750px</td><td>970px</td></tr><tr><td>Class 前缀</td><td>.col-xs-</td><td>.col-sm-</td><td>.col-md-</td></tr><tr><td>列数量和</td><td>12</td><td>12</td><td>12</td></tr><tr><td>最大列宽</td><td>Auto</td><td>60px</td><td>78px</td></tr><tr><td>间隙宽度</td><td>30px（一个列的每边分别 15px）</td><td>30px（一个列的每边分别 15px）</td><td>30px（一个列的每边分别 15px）</td></tr><tr><td>可嵌套</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>偏移量</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>列排序</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table><h1 id="基本的网格结构"><a href="#基本的网格结构" class="headerlink" title="基本的网格结构"></a>基本的网格结构</h1><p>下面是 Bootstrap 网格的基本结构：</p><pre><code> &lt;div style=&quot;border: 1px&quot; class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-4 col-xs-4&quot; style=&quot;border: 1px red solid&quot;&gt;左&lt;/div&gt;        &lt;div class=&quot;col-md-4 col-xs-4&quot; style=&quot;border: 1px red solid&quot;&gt;右&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;border: 1px yellow solid&quot;&gt;左&lt;/div&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;border: 1px yellow solid&quot;&gt;右&lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>让我们来看几个简单的网格实例：</p><ul><li>实例：堆叠的水平</li></ul><ul><li><p>实例：中型和大型设备</p></li><li><p>实例：手机、平板电脑、台式电脑</p></li></ul><h1 id="响应式的列重置"><a href="#响应式的列重置" class="headerlink" title="响应式的列重置"></a>响应式的列重置</h1><p>以下实例包含了4个网格，但是我们在小设备浏览时无法确定网格显示的位置。</p><p>为了解决这个问题，可以使用 .clearfix class和 响应式实用工具来解决，如下面实例所示：</p><pre><code>&lt;div class=&quot;container&quot;&gt;&lt;div class=&quot;row&quot; &gt;    &lt;div class=&quot;col-xs-6 col-sm-3&quot;         style=&quot;background-color: #dedef8;        box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;col-xs-6 col-sm-3&quot;     style=&quot;background-color: #dedef8;box-shadow:     inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do         eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut         enim ad minim veniam, quis nostrud exercitation ullamco laboris         nisi ut aliquip ex ea commodo consequat.        &lt;/p&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do         eiusmod tempor incididunt ut.         &lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;clearfix visible-xs&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;col-xs-6 col-sm-3&quot;     style=&quot;background-color: #dedef8;    box-shadow:inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Ut enim ad minim veniam, quis nostrud exercitation ullamco         laboris nisi ut aliquip ex ea commodo consequat.         &lt;/p&gt;    &lt;/div&gt;    &lt;div class=&quot;col-xs-6 col-sm-3&quot;     style=&quot;background-color: #dedef8;box-shadow:     inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do         eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut         enim ad minim         &lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><h4 id="请看一下效果："><a href="#请看一下效果：" class="headerlink" title="请看一下效果："></a>请看一下效果：</h4><p>电脑端案例：浏览器上调整窗口大小查看变化，或在您手机上查看效果。<br><img src="https://i.imgur.com/EYrjm6F.png" alt> </p><p><img src="https://i.imgur.com/CpZF2sM.png" alt></p><h1 id="偏移列"><a href="#偏移列" class="headerlink" title="偏移列"></a>偏移列</h1><p>偏移是一个用于更专业的布局的有用功能。它们可用来给列腾出更多的空间。例如，.col-xs-* 类不支持偏移，但是它们可以简单地通过使用一个空的单元格来实现该效果。</p><p>为了在大屏幕显示器上使用偏移，请使用 <code>.col-md-offset-*</code> 类。这些类会把一个列的左外边距（margin）增加 <em> 列，其中 </em> 范围是从 1 到 11。</p><p>在下面的实例中，我们有 <div class="col-md-6">..</div>，我们将使用 <code>.col-md-offset-3 class</code> 来居中这个 div。</p><pre><code>&lt;div class=&quot;container&quot;&gt;&lt;h1&gt;Hello, Bootstrap!&lt;/h1&gt;&lt;div class=&quot;row&quot; &gt;    &lt;div class=&quot;col-md-6 col-md-offset-3&quot;         style=&quot;background-color: #dedef8;box-shadow:     inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing            elit.        &lt;/p&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p>结果如下：<br><img src="https://i.imgur.com/Ibr4UGL.png" alt></p><h1 id="嵌套列"><a href="#嵌套列" class="headerlink" title="嵌套列"></a>嵌套列</h1><p>为了在内容中嵌套默认的网格，请添加一个新的 <strong>.row</strong>，并在一个已有的 <strong>.col-md-*</strong> 列内添加一组 <strong>.col-md-*</strong> 列。被嵌套的行应包含一组列，这组列个数不能超过12（其实，没有要求你必须占满12列）。</p><p>在下面的实例中，布局有两个列，第二列被分为两行四个盒子。</p><div class="container">   <h1>Hello, world!</h1>   <div class="row"><pre><code>  &lt;div class=&quot;col-md-3&quot; style=&quot;background-color: #dedef8;box-shadow:      inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;     &lt;h4&gt;第一列&lt;/h4&gt;     &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit.&lt;/p&gt;  &lt;/div&gt;  &lt;div class=&quot;col-md-9&quot; style=&quot;background-color: #dedef8;box-shadow:      inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;     &lt;h4&gt;第二列 - 分为四个盒子&lt;/h4&gt;     &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;background-color: #B18904;           box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;           &lt;p&gt;Consectetur art party Tonx culpa semiotics. Pinterest               assumenda minim organic quis.           &lt;/p&gt;        &lt;/div&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;background-color: #B18904;           box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;           &lt;p&gt; sed do eiusmod tempor incididunt ut labore et dolore magna               aliqua. Ut enim ad minim veniam, quis nostrud exercitation               ullamco laboris nisi ut aliquip ex ea commodo consequat.           &lt;/p&gt;        &lt;/div&gt;     &lt;/div&gt;     &lt;div class=&quot;row&quot;&gt;        &lt;div class=&quot;col-md-6&quot; style=&quot;background-color: #B18904;           box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;           &lt;p&gt;quis nostrud exercitation ullamco laboris nisi ut               aliquip ex ea commodo consequat.           &lt;/p&gt;        &lt;/div&gt;           &lt;div class=&quot;col-md-6&quot; style=&quot;background-color: #B18904;           box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;           &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit,               sed do eiusmod tempor incididunt ut labore et dolore magna               aliqua. Ut enim ad minim.&lt;/p&gt;        &lt;/div&gt;     &lt;/div&gt;  &lt;/div&gt;</code></pre>   </div></div>**运行效果：**![](https://i.imgur.com/qi2aEBu.png)<p>注：CSS3 box-shadow 属性向 div 元素添加阴影：<a href="https://www.runoob.com/cssref/css3-pr-box-shadow.html" title="CSS3 box-shadow 属性" target="_blank" rel="noopener">https://www.runoob.com/cssref/css3-pr-box-shadow.html</a></p><h1 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h1><p>Bootstrap 网格系统另一个完美的特性，就是您可以很容易地以一种顺序编写列，然后以另一种顺序显示列。</p><p>您可以很轻易地改变带有 <code>.col-md-push-*</code> 和 <code>.col-md-pull-*</code> 类的内置网格列的顺序，其中 * 范围是从 1 到 11。</p><p>在下面的实例中，我们有两列布局，左列很窄，作为侧边栏。我们将使用 <code>.col-md-push-*</code>和 <code>.col-md-pull-*</code> 类来互换这两列的顺序</p><pre><code>&lt;div class=&quot;row&quot;&gt;    &lt;p&gt;排序前&lt;/p&gt;    &lt;div class=&quot;col-md-4&quot; style=&quot;background-color: #dedef8;     box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        我在左边    &lt;/div&gt;    &lt;div class=&quot;col-md-8&quot; style=&quot;background-color: #dedef8;     box-shadow: inset 1px -1px 1px #444, inset -1px 1px 1px #444;&quot;&gt;        我在右边    &lt;/div&gt;&lt;/div&gt;&lt;br&gt; &lt;div class=&quot;row&quot;&gt;    &lt;p&gt;排序后&lt;/p&gt;    &lt;div class=&quot;col-md-4 col-md-push-8&quot;         style=&quot;background-color: #dedef8;     box-shadow: inset 1px -1px 1px #444,     inset -1px 1px 1px #444;&quot;&gt;        我在左边    &lt;/div&gt;    &lt;div class=&quot;col-md-8 col-md-pull-4&quot;         style=&quot;background-color: #dedef8;     box-shadow: inset 1px -1px 1px #444,     inset -1px 1px 1px #444;&quot;&gt;        我在右边    &lt;/div&gt;&lt;/div&gt;</code></pre><p>演示结果：<img src="https://i.imgur.com/IJwU12i.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware Workstation Pro 15下载</title>
      <link href="/2018/03/18/vmware-workstation-pro-15-xia-zai/"/>
      <url>/2018/03/18/vmware-workstation-pro-15-xia-zai/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows平台最强虚拟机软件已经更新到了VM15-版本了，VMware-Workstation-Pro-15-全面进行了改造重新制作了UI界面及LOGO图标，VMware-Workstation-允许操作系统和应用程序在一台虚拟机内部运行。"><a href="#Windows平台最强虚拟机软件已经更新到了VM15-版本了，VMware-Workstation-Pro-15-全面进行了改造重新制作了UI界面及LOGO图标，VMware-Workstation-允许操作系统和应用程序在一台虚拟机内部运行。" class="headerlink" title="Windows平台最强虚拟机软件已经更新到了VM15 版本了，VMware Workstation Pro 15 全面进行了改造重新制作了UI界面及LOGO图标，VMware Workstation 允许操作系统和应用程序在一台虚拟机内部运行。"></a>Windows平台最强虚拟机软件已经更新到了VM15 版本了，VMware Workstation Pro 15 全面进行了改造重新制作了UI界面及LOGO图标，VMware Workstation 允许操作系统和应用程序在一台虚拟机内部运行。</h1><h2 id="虚拟机是独立运行主机操作系统的离散环境。在-VMware-Workstation-中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。"><a href="#虚拟机是独立运行主机操作系统的离散环境。在-VMware-Workstation-中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。" class="headerlink" title="虚拟机是独立运行主机操作系统的离散环境。在 VMware Workstation 中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。"></a>虚拟机是独立运行主机操作系统的离散环境。在 VMware Workstation 中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。</h2><h2 id="你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。"><a href="#你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。" class="headerlink" title="你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。"></a>你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。</h2><p><img src="https://i.imgur.com/S0b5hyj.png" alt></p><p><img src="https://i.imgur.com/FHp061U.png" alt></p><p><em><em> 激活密钥许可证VMware Workstation Pro 15 </em></em></p><p><em>激活许可证</em></p><p>UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA</p><p>VF750-4MX5Q-488DQ-9WZE9-ZY2D6</p><p>UU54R-FVD91-488PP-7NNGC-ZFAX6</p><p>YC74H-FGF92-081VZ-R5QNG-P6RY4</p><p>YC34H-6WWDK-085MQ-JYPNX-NZRA2</p><p><strong>下载地址VMware Workstation Pro 15.5.0 Build 14665864</strong></p><p><em><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.0-14665864.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.5.0-14665864.exe</a></em></p><p><em>VMware Workstation Pro 15.1.0 Build 13591040<br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe</a></em></p><p><em>VMware Workstation Pro 14.1.3 Build 9474260<br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.3-9474260.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-14.1.3-9474260.exe</a></em><br><em>VMware Workstation Pro 12.5.9 Build 7535481<br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-12.5.9-7535481.exe</a></em></p><p><em>VMware Workstation 10.0.7 Build 2844087<br><a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-10.0.7-2844087.exe</a></em></p><h2 id="黑苹果链接（感谢论坛友人分享）"><a href="#黑苹果链接（感谢论坛友人分享）" class="headerlink" title="黑苹果链接（感谢论坛友人分享）"></a>黑苹果链接（感谢论坛友人分享）</h2><p>链接：<a href="https://pan.baidu.com/s/1ZouLWPk2QGdAapwrWjuz_Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ZouLWPk2QGdAapwrWjuz_Q</a><br>提取码：xxmn </p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu与centos的区别</title>
      <link href="/2018/03/16/ubuntu-yu-centos-de-qu-bie/"/>
      <url>/2018/03/16/ubuntu-yu-centos-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1 id="ubuntu与centos的区别"><a href="#ubuntu与centos的区别" class="headerlink" title="ubuntu与centos的区别"></a>ubuntu与centos的区别</h1><p><strong>共同点</strong></p><p>1.两个系统都分别有桌面系统与服务器系统，不过ubuntu的桌面从外观上来看要比centos的漂亮<br><img src="https://i.imgur.com/wG2Wijz.png" alt></p><p><strong>不同点</strong></p><p>1.centos中新建的普通用户是没有sudo权限的，如果想让普通用户拥有sudo权限需要在/etc/sudoers文件中添加用户的权限，而ubuntu系统普通用户想要使用sudo权限  直接使用sudo +命令行的方式就可以了<br><img src="https://i.imgur.com/F9j1bQf.png" alt><br><img src="https://i.imgur.com/gO8IHXy.png" alt></p><p>2.安装软件包命令格式不一样。centos使用yum的方式，而Ubuntu使用apt-get 方式。<br><img src="https://i.imgur.com/5HVsSwb.png" alt></p><p>3.由于centos是基于redhat的，所以centos支持rpm包，但Ubuntu不支持。<br><img src="https://i.imgur.com/ncFb1r6.png" alt></p><p>4.现在虽然说ubuntu系统也可以使用服务器端来进行使用了，但相对centos来说并没有centos稳定。而且在一些比较知名的技术论坛大多都是关于centos的，所以在遇到问题查询资料的时候相对要比ubuntu要更方便一些。如下图中centos中文站技术论坛，是很多学习者经常查询问题的地方。<br><img src="https://i.imgur.com/dZWrs2n.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ubuntu </tag>
            
            <tag> centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git page搭建个人博客教程</title>
      <link href="/2018/03/11/hexo-github-1/"/>
      <url>/2018/03/11/hexo-github-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>有任何问题请联系我扣扣：1260842695，vx：szhll5201314，24小时随时在线哦<br>如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。</p></blockquote><h3 id="我的博客源代码地址"><a href="#我的博客源代码地址" class="headerlink" title="我的博客源代码地址"></a>我的博客源代码地址</h3><p>大家可以直接素质二连，star&amp;fork我的博客源代码：<a href="https://github.com/leblog" target="_blank" rel="noopener">https://github.com/leblog</a><br>然后改改配置就可以写文章啦。</p><p>首先将所有文件下载到本地。<br>解压node_modules.zip，然后删除node_modules.zip和.git文件夹。<br>还缺一个字体（为图片添加水印需要用到），去C:\Windows\Fonts下找到STSong Regular，复制到hexo-matery-modified文件夹下。</p><h3 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h3><p>如果你不想自己从头开始慢慢自定义主题的话，可以直接下载我的修改好的主题，然后稍微修改几个地方就好了：</p><p>根目录配置文件_config.yml和主题目录配置文件_config.yml中修改个人信息。<br>根目录配置文件中修改deploy一栏的repository。<br>根目录配置文件中修改baidu_url_submit一栏的token。<br>主题配置文件中修改gitalk一栏，修改方法见正文。<br>当然前提是个性化设置章节之前的环境还是需要配置好！</p><p>平时常用命令：</p><pre>    <code>hexo g  # 生成博客网页文件hexo s  # 本地预览博客hexo d  # 上传网页文件到github    </code></pre><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>17年9月的时候开始搭建了第一个自己的独立博客，到现在也稍微像模像样了。很多小伙伴应该也想过搭建一个自己的博客，网上也有一堆详细教程。我在此稍稍总结一下具体的搭建步骤，另外网上很少有修改博客源码的个性化教程，我就稍稍分享一下我的一些修改经验，更多的个性化操作需要你自己以后去摸索。</p><p>具体效果可以参观我的博客：<b>leblog.github.io</b>，欢迎大家支持。</p><p>我不是一个前端程序员，有些东西不是很了解，写的有问题或有改进的地方请大家指出。</p><p>首先要了解一下我们搭建博客要用到的框架。Hexo是高效的静态站点生成框架，它基于Node.js。通过Hexo，你可以直接使用Markdown语法来撰写博客。相信很多小伙伴写工程都写过README.md文件吧，对，就是这个格式的！写完后只需两三条命令即可将生成的网页上传到你的github上，然后别人就可以看到你的网页啦。是不是很简单？你无需关心网页源代码的具体细节，你只需要用心写好你的博客内容就行。</p><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><hr><ul><li>安装Node.js</li><li>添加国内镜像源</li><li>安装Git</li><li>注册Github账号</li><li>安装Hexo</li><li>连接Github与本地</li><li>写文章、发布文章</li></ul><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>首先下载稳定版<a>Node.js</a>，我这里给的是64位的。</p><p>安装选项全部默认，一路点击Next。</p><p>最后安装好之后，按Win+R打开命令提示符，输入node -v和npm -v，如果出现版本号，那么就安装成功了。</p><p>添加国内镜像源<br>如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p><pre>    <code>npm config set registry https://registry.npm.taobao.org    </code></pre><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git[下载地址]。</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择Use Git from the Windows Command Prompt，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入git –version验证是否安装成功</p><p>注册Github账号<br>接下来就去注册一个github账号，用来存放我们的网站。大多数小伙伴应该都有了吧，作为一个合格的程序猿（媛）还是要有一个的。</p><p>打开<a href="https://github.com/，新建一个项目，如下所示：" target="_blank" rel="noopener">https://github.com/，新建一个项目，如下所示：</a></p><p><img src="2.png" alt><br>然后如下图所示，输入自己的项目名字，后面一定要加.github.io后缀，README初始化也要勾上。名称一定要和你的github名字完全一样，比如你github名字叫abc，那么仓库名字一定要是abc.github.io<br><img src="3.png" alt><br>然后项目就建成了，点击Settings，向下拉到最后有个GitHub Pages，点击Choose a theme选择一个主题。然后等一会儿，再回到GitHub Pages，会变成下面这样：<br><img src="4.png" alt><br>然后完成。</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在D:\study\program\blog目录下。</p><p>在该目录下右键点击Git Bash Here，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入npm i hexo-cli -g安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入hexo -v验证是否安装成功。</p><p>然后就要初始化我们的网站，输入hexo init初始化文件夹，接着输入npm install安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入hexo g生成静态网页，然后输入hexo s打开本地服务器，然后浏览器打开<b><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></b>，就可以看到我们的博客啦，效果如下：<br><img src="5.png" alt></p><p>按ctrl+c关闭本地服务器。</p><p>连接Github与本地服务器<br>首先右键打开git bash，然后输入下面命令：</p><pre>    <code>    git config --global user.name "lebolg"    git config --global user.email "1260842695@qq.com"    </code></pre><p>用户名和邮箱根据你注册github的信息自行修改。<br>然后生成密钥SSH key：</p><pre>    <code>        ssh-keygen -t rsa -C "1260842695@qq.com"    </code></pre><p>打开github，在头像下面点击settings，再点击SSH and GPG keys，新建一个SSH，名字随便。</p><p>git bash中输入</p><pre>    <code>        cat ~/.ssh/id_rsa.pub    </code></pre><p>将输出的内容复制到框中，点击确定保存。</p><p>输入ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，如果如下图所示，出现你的用户名，那就成功了。<br><img src="6.png" alt><br>打开博客根目录下的_config.yml文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><pre>    <code>        deploy:          type: git          repository: https://github.com/lebolg/lebolg.github.io          branch: master    </code></pre><p>repository修改为你自己的github项目地址。</p><h3 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h3><p>首先在博客根目录下右键打开git bash，安装一个扩展npm i hexo-deployer-git。</p><p>然后输入hexo new post “article title”，新建一篇文章。</p><p>然后打开D:\study\program\blog\source_posts的目录，可以发现下面多了一个文件夹和一个.md文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p>编写完markdown文件后，根目录下输入hexo g生成静态网页，然后输入hexo s可以本地预览效果，最后输入hexo d上传到github上。这时打开你的github.io主页就能看到发布的文章啦。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么说程序员都应该写一写博客</title>
      <link href="/2018/03/10/2018-leblog/"/>
      <url>/2018/03/10/2018-leblog/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><h1 id="不是大牛就不能写博客了吗？"><a href="#不是大牛就不能写博客了吗？" class="headerlink" title="不是大牛就不能写博客了吗？"></a>不是大牛就不能写博客了吗？</h1><hr><p>几乎每一个程序员都听说过写博客有很多好处，但真的动手去写的却很少。其中有一个很重要的原因就是，有些人心里会认为：我不是大牛，写出来的博客没意义。</p><blockquote><p>有任何问题请联系我扣扣：1260842695，vx：szhll5201314，24小时随时在线哦<br>如果觉得有用的话可以看心情打赏一杯奶茶，我会很开心哒。</p></blockquote><p><img src="1.png" alt><br><strong>有这种心理很正常，只是每个人表现出来的方式不太一样。</strong>像我五音不全，就非常讨厌去KTV，就算因为公司团建同学聚会实在拗不过别人真的去了，也从来不开口唱，因为怕被别人笑。有些人不爱打扮不是因为完全没有眼光没有审美基础，其实他们也知道什么衣服好看什么衣服不好看，只是因为觉得自己长相普通身材不好，所以就不愿意把时间精力花在这些地方。<strong>归根到底，就是觉得只有出色才应该表现自己。</strong><br><img src="2.png" alt><br><strong>你不是大牛，照样可以写博客。</strong>有一次，我用几个流行的框架组合搭建一个新项目，过程中报了一个错，报错的日志信息不清不楚，完全不知道从何下手。于是就把自己情况提取关键字在网上搜索，看到有一个网友写的博客记录了一模一样的问题，并且提供了他的解决办法。我根据他说的步骤去做，果然就解决了这个问题。他不是大牛，那篇博客也写得非常简单，但是的确解决了这个困扰了我大半天的问题，帮我节省了很多时间。我们在学习工作的时候，也会遇到很多问题，这些问题很有可能别人一样也会遇到。解决问题之后，我们可以把解决过程写成一篇简单的博客，既可以让自己积累经验，也能为其他有需要的网友提供帮助。</p><p><img src="3.png" alt><br><strong>你不是大牛，更应该试试写博客。</strong>无论是程序开发，还是测试运维，吃的这碗饭都是干技术的。技术更新速度非常快，所以我们即便离开了校园照样要学习许多新知识。有些技术大牛，由于经验丰富和技术水平高，面对一个新出来的技术，可能只需要看看官方文档和源代码，再写几个简单的实验小项目就已经熟悉和掌握了。我们不是大牛，有可能因为英文水平不够看不懂官方文档，有可能因为经验不足不知道怎么研究几十万行级别的源代码，甚至有可能不知道要怎么搭建一个使用这个新技术的项目。这时候我们就需要去看书，看技术博客，借助资料去学习，根据别人指出的方向去摸索。这个过程当中，我们就应该试试写博客，把学习笔记写下来，把自己摸索的经历写下来，整理学习的思路，而不是看过就忘、学过就丢。</p><p>#不是大牛就不能写博客了吗？<br>其实这个问题就是一层窗户纸，大家都知道自己能写，而且还有可能可以写得很好。你的博客一定会有其不可替代的意义，既可以为他人提供帮助，也是对自己在学习公众道路上有所助益的一件事。即便你现在的技术水平不高，还是一个刚入门的菜鸟，也一样应该试着写一写博客。</p><h1 id="我的博客历史之红与黑"><a href="#我的博客历史之红与黑" class="headerlink" title="我的博客历史之红与黑"></a>我的博客历史之红与黑</h1><hr><p>写博客是一件并不困难的事，但是也绝对不容易，不然也不会有那么多人还没有开始写自己的第一篇博客。坚持写博客是一件有点困难的事情，在这一点上我深有体会。接下来我想跟大家分享一下近几年来写博客和公众号文章的感想，有很多提起就觉得尴尬的黑历史，也有一些自己觉得很有意义的红历史。</p><p><strong>先从黑历史讲起。</strong>一开始写的博客很烂，现在回头去看简直是辣眼睛。我第一篇在博客园发的博客是讲如何搭建Java Web MVC框架的，直到现在还能在我的博客主页里面看到。当时我还在上大学，其实对web开发和MVC框架都是一窍不通的，结果写出来的东西也是乱七八糟，无论是排版还是内容都惨不忍睹。</p><p><strong>再讲讲红历史。</strong>从我写的第一篇博客开始就给了我很多的鼓励，这主要是体现在阅读量和友好的评论这两方面上。有了大家的鼓励，我才能坚持到现在。写的第一篇我觉得比较好的博客就是《程序猿崛起2》，虽然质量仍然不高，但是比起之前的文章来说，有了自己的观点和想法，显得没有那么空洞。再说说我的公众号，因为读者组成的关系，所以在上面很少会专门谈论技术，主要是写一些我在看书过程中产生的一些想法和观点。受到《暗时间》的影响，我平时看了大量的关于心理学、社会学的书。有的时候每周一篇，有的时候半个月一篇，就这样坚持了三年。现在的写作能力和思考能力，都有了比之前不少的进步。</p><h1 id="互联网最重要的分享-这才是互联网最可贵的互助精神"><a href="#互联网最重要的分享-这才是互联网最可贵的互助精神" class="headerlink" title="互联网最重要的分享,这才是互联网最可贵的互助精神"></a>互联网最重要的分享,这才是互联网最可贵的互助精神</h1><p>写博客写文章的人，都会遇到两个麻烦。第一个麻烦就是有人会泼你冷水，甚至是打着好心提建议的旗号泼你的冷水。不要理会他们的说三道四，直接就把他们拉黑就好。新手一开始需要的是鼓励和认同，绝对不是那些非建设性意见的批评。曾经有个大学同学看了我的文章，说：“你写的没什么内容啊，就是一些大话。”我直接就把他屏蔽掉了。第二个麻烦就是坚持不下去，写了一两篇就再也不写了。首先你要培养对写作的兴趣，感受写文章的快乐。当然了，像我这样会为一个关注数只有四五百的公众号每个星期写文章、每篇文章顶了天一百多阅读数的人来说，如果不是真心喜欢，根本坚持不下来。然后你要想想那些朋友和网友的鼓励，不要辜负他们的一片好心。我经常会特别感谢那些在我的博客下面评论“加油”的人，因为简简单单的几个字就能给我很大的力量，鼓励我继续写下去。我们要相信，只要坚持下去，除了那些找存在感的人泼你冷水，还有更多的热心人给你加油鼓劲。</p><h1 id="实干兴邦，空谈误国"><a href="#实干兴邦，空谈误国" class="headerlink" title="实干兴邦，空谈误国"></a>实干兴邦，空谈误国</h1><p>动动手，让我们开始写一写博客<br>列举了这么多写博客的好处，相信已经有很多人都已经跃跃欲试了。不如趁热打铁，我们现在就花几分钟的时间来体验一下写博客到底要怎么写。不要紧张，这一点都不难，只要接下来一步一步跟着做就可以了。</p><p><strong>最后再多说两句</strong><br>其实分享知识和可以帮助学习工作的方式有很多，并不一定就是要写博客，但这却是最有普及价值和最简单的一种途径。我写这篇文章的初衷，就是希望让更多的人参与到写博客这件有意义的事情中来，从中受益的同时也可以惠及他人。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
